<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Finance Tracker v1.8.4</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); min-height: 100vh; padding: 20px; }
        #root { max-width: 1400px; margin: 0 auto; }
        .app-container { background: #0f1419; border-radius: 20px; box-shadow: 0 20px 60px rgba(0,0,0,0.5); overflow: hidden; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; font-weight: 700; }
        .header .version { font-size: 0.9em; opacity: 0.9; }
        .tab-navigation { display: flex; background: #1a1f2e; border-bottom: 2px solid #2d3748; overflow-x: auto; }
        .tab-button { flex: 1; min-width: 150px; padding: 18px 24px; background: transparent; border: none; cursor: pointer; font-size: 1em; font-weight: 600; color: #a0aec0; transition: all 0.3s ease; border-bottom: 3px solid transparent; }
        .tab-button:hover { background: #2d3748; color: #e2e8f0; }
        .tab-button.active { color: #667eea; border-bottom-color: #667eea; background: #0f1419; }
        .tab-content { padding: 30px; background: #0f1419; }
        .yearly-overview { background: #1a1f2e; padding: 40px; border-radius: 15px; margin-bottom: 30px; text-align: center; }
        .yearly-overview h2 { color: #a0aec0; font-size: 1.2em; margin-bottom: 15px; text-transform: uppercase; letter-spacing: 2px; }
        .yearly-overview .amount { font-size: 3.5em; font-weight: 700; margin-bottom: 10px; }
        .yearly-overview.income .amount { color: #28a745; }
        .yearly-overview.expense .amount { color: #dc3545; }
        .yearly-overview.net .amount.positive { color: #28a745; }
        .yearly-overview.net .amount.negative { color: #dc3545; }
        .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .summary-card { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 25px; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
        .summary-card h3 { font-size: 0.9em; opacity: 0.9; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; }
        .summary-card .amount { font-size: 2em; font-weight: 700; }
        .summary-card .subtitle { font-size: 0.85em; opacity: 0.85; margin-top: 8px; }
        .section { background: #1a1f2e; padding: 25px; border-radius: 15px; margin-bottom: 20px; }
        .section h2 { color: #667eea; margin-bottom: 20px; font-size: 1.5em; }
        .category-filters { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; }
        .category-filter-btn { background: #2d3748; color: #a0aec0; border: 2px solid transparent; padding: 10px 20px; border-radius: 25px; font-size: 0.9em; font-weight: 600; cursor: pointer; transition: all 0.3s ease; }
        .category-filter-btn:hover { background: #4a5568; color: #e2e8f0; }
        .category-filter-btn.active { background: #667eea; color: white; border-color: #667eea; }
        .dashboard-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        @media (max-width: 968px) { .dashboard-grid { grid-template-columns: 1fr; } }
        .debt-overview-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 15px; }
        .debt-mini-card { background: #1a1f2e; padding: 18px; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); border-left: 4px solid #ffc107; }
        .debt-mini-card h4 { color: #e2e8f0; margin-bottom: 8px; font-size: 1em; }
        .debt-mini-card .debt-amount { font-size: 1.4em; font-weight: 700; color: #667eea; margin-bottom: 8px; }
        .debt-mini-card .debt-info { font-size: 0.85em; color: #a0aec0; margin-bottom: 4px; }
        .form-group { margin-bottom: 20px; }
        .form-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px; }
        label { display: block; margin-bottom: 8px; color: #a0aec0; font-weight: 600; font-size: 0.9em; }
        input, select { width: 100%; padding: 12px; border: 2px solid #2d3748; border-radius: 8px; font-size: 1em; transition: border-color 0.3s; background: #0f1419; color: #e2e8f0; }
        input:focus, select:focus { outline: none; border-color: #667eea; }
        button { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 12px 30px; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; }
        button:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4); }
        button:active { transform: translateY(0); }
        button.secondary { background: #6c757d; margin-left: 10px; }
        button.danger { background: #dc3545; }
        button.success { background: #28a745; }
        .transaction-list, .payment-list, .debt-list { margin-top: 20px; }
        .transaction-item, .payment-item, .debt-item { background: #1a1f2e; padding: 20px; border-radius: 10px; margin-bottom: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: flex; justify-content: space-between; align-items: center; }
        .transaction-item.income { border-left: 4px solid #28a745; }
        .transaction-item.expense { border-left: 4px solid #dc3545; }
        .payment-item.paid { opacity: 0.6; border-left: 4px solid #28a745; }
        .payment-item.unpaid { border-left: 4px solid #ffc107; }
        .item-details h4 { color: #e2e8f0; margin-bottom: 5px; }
        .item-details p { color: #a0aec0; font-size: 0.9em; }
        .item-amount { font-size: 1.3em; font-weight: 700; }
        .item-amount.positive { color: #28a745; }
        .item-amount.negative { color: #dc3545; }
        .controls { display: flex; gap: 10px; margin-top: 20px; }
        .collapsible-section { margin-bottom: 15px; }
        .collapsible-header { background: #667eea; color: white; padding: 15px 20px; border-radius: 10px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: background 0.3s; }
        .collapsible-header:hover { background: #5568d3; }
        .collapsible-header h3 { margin: 0; font-size: 1.2em; }
        .collapsible-content { padding: 20px; background: #0f1419; border-radius: 0 0 10px 10px; margin-top: 2px; }
        .debt-item { border-left: 4px solid #ffc107; }
        .progress-bar { width: 100%; height: 8px; background: #2d3748; border-radius: 4px; overflow: hidden; margin-top: 10px; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #28a745, #20c997); transition: width 0.3s ease; }
        .debt-details { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-top: 15px; font-size: 0.9em; }
        .debt-detail-item { padding: 10px; background: #1a1f2e; border-radius: 5px; }
        .debt-detail-item label { font-size: 0.8em; color: #a0aec0; margin-bottom: 5px; }
        .debt-detail-item .value { font-weight: 700; color: #e2e8f0; }
        .paid-badge { background: #28a745; color: white; padding: 4px 12px; border-radius: 12px; font-size: 0.8em; font-weight: 600; margin-left: 10px; }
        .auto-badge { background: #17a2b8; color: white; padding: 4px 12px; border-radius: 12px; font-size: 0.8em; font-weight: 600; margin-left: 10px; }
        .manual-badge { background: #6c757d; color: white; padding: 4px 12px; border-radius: 12px; font-size: 0.8em; font-weight: 600; margin-left: 10px; }
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 1000; }
        .modal { background: #1a1f2e; border-radius: 15px; padding: 30px; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto; }
        .modal h2 { color: #667eea; margin-bottom: 20px; }
        @media (max-width: 768px) { .tab-navigation { flex-wrap: wrap; } .tab-button { flex: 1 1 50%; } .summary-grid { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const formatCurrency = (amount) => new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(amount);
        const parseLocalDate = (dateStr) => { const [year, month, day] = dateStr.split('-').map(Number); return new Date(year, month - 1, day); };
        const getCurrentFinancialMonth = () => { const today = new Date(); const day = today.getDate(); const month = today.getMonth(); const year = today.getFullYear(); if (day >= 28) { return new Date(year, month + 1, 1); } else { return new Date(year, month, 1); } };
        const getFinancialMonthRange = (date) => { const month = date.getMonth(); const year = date.getFullYear(); const start = new Date(year, month - 1, 28); const end = new Date(year, month, 27, 23, 59, 59); return { start, end }; };
        const getMonthKey = (date) => { const d = new Date(date); return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`; };

        function FinanceTracker() {
            // Predefined categories
            const expenseCategories = ['Food', 'Groceries', 'Subscriptions', 'Home', 'Car Payments', 'Personal', 'Pets', 'Utilities', 'Gas (cars)', 'Debt', 'Insurance', 'Kids', 'Savings', 'House cleaning', 'Entertainment', 'Healthcare', 'Transportation', 'Other'];
            const incomeCategories = ['Salary', 'Freelance', 'Investment', 'Gift', 'Bonus', 'Refund', 'Other'];
            
            const [activeTab, setActiveTab] = useState('dashboard');
            const [transactions, setTransactions] = useState([]);
            const [recurringPayments, setRecurringPayments] = useState([]);
            const [debts, setDebts] = useState([]);
            const [paidPayments, setPaidPayments] = useState({});
            const [currentMonth, setCurrentMonth] = useState(getCurrentFinancialMonth());
            const hasAutoProcessed = useRef(false);

            useEffect(() => {
                const savedTransactions = localStorage.getItem('transactions');
                const savedPayments = localStorage.getItem('recurringPayments');
                const savedDebts = localStorage.getItem('debts');
                const savedPaidPayments = localStorage.getItem('paidPayments');
                if (savedTransactions) setTransactions(JSON.parse(savedTransactions));
                if (savedPayments) setRecurringPayments(JSON.parse(savedPayments));
                if (savedDebts) setDebts(JSON.parse(savedDebts));
                if (savedPaidPayments) setPaidPayments(JSON.parse(savedPaidPayments));
            }, []);

            useEffect(() => { localStorage.setItem('transactions', JSON.stringify(transactions)); }, [transactions]);
            useEffect(() => { localStorage.setItem('recurringPayments', JSON.stringify(recurringPayments)); }, [recurringPayments]);
            useEffect(() => { localStorage.setItem('debts', JSON.stringify(debts)); }, [debts]);
            useEffect(() => { localStorage.setItem('paidPayments', JSON.stringify(paidPayments)); }, [paidPayments]);

            // Auto-process recurring payments when their due date passes (only on mount and month change)
            useEffect(() => {
                if (recurringPayments.length === 0) {
                    hasAutoProcessed.current = false;
                    return;
                }
                
                const monthKey = getMonthKey(currentMonth);
                
                // Prevent duplicate processing in the same month
                if (hasAutoProcessed.current === monthKey) return;
                hasAutoProcessed.current = monthKey;
                
                const today = new Date();
                const { start } = getFinancialMonthRange(currentMonth);
                
                let newTransactions = [...transactions];
                let newPaidPayments = {...paidPayments};
                let hasChanges = false;
                
                recurringPayments.forEach(payment => {
                    // Skip if not auto-pay
                    if (!payment.auto) return;
                    
                    // Skip if already marked as paid this month
                    const paymentKey = `${monthKey}-${payment.id}`;
                    if (newPaidPayments[paymentKey]) return;
                    
                    // Calculate payment date
                    let paymentDate;
                    if (payment.dueDay >= 28) {
                        paymentDate = new Date(start.getFullYear(), start.getMonth(), payment.dueDay);
                    } else {
                        paymentDate = new Date(start.getFullYear(), start.getMonth() + 1, payment.dueDay);
                    }
                    
                    // Check if due date has passed
                    if (today >= paymentDate) {
                        // Check if transaction already exists for this payment
                        const transactionExists = newTransactions.some(t => {
                            if (t.type !== 'expense') return false;
                            
                            // Check if date is within current financial month
                            const tDate = parseLocalDate(t.date);
                            if (tDate < start || tDate > new Date(start.getFullYear(), start.getMonth() + 1, 27)) return false;
                            
                            // Check if amounts are similar (within $1)
                            const amountMatch = Math.abs(parseFloat(t.amount) - parseFloat(payment.amount)) < 1.0;
                            if (!amountMatch) return false;
                            
                            // Check if categories match (if payment has category)
                            if (payment.category && t.category) {
                                if (payment.category.toLowerCase() !== t.category.toLowerCase()) return false;
                            }
                            
                            // Check if description contains ALL significant words from payment name (3+ chars)
                            const paymentWords = payment.name.toLowerCase().split(/\s+/).filter(w => w.length >= 3);
                            const descWords = t.description.toLowerCase();
                            
                            // Require ALL words to match, not just one
                            const allWordsMatch = paymentWords.every(word => descWords.includes(word));
                            
                            return allWordsMatch;
                        });
                        
                        if (!transactionExists) {
                            // Auto-create transaction
                            newTransactions.push({
                                type: 'expense',
                                amount: parseFloat(payment.amount),
                                description: `${payment.name} (Auto)`,
                                category: payment.category,
                                date: paymentDate.toISOString().split('T')[0],
                                id: Date.now() + Math.random()
                            });
                            hasChanges = true;
                        }
                        
                        // Mark as paid
                        newPaidPayments[paymentKey] = true;
                        hasChanges = true;
                        
                        // Update linked debt if exists
                        if (payment.linkedDebt) {
                            const linkedDebtIndex = debts.findIndex(d => d.id === parseInt(payment.linkedDebt));
                            if (linkedDebtIndex !== -1) {
                                const debt = debts[linkedDebtIndex];
                                const interestRate = parseFloat(debt.interestRate) || 0;
                                const monthlyInterestRate = interestRate / 100 / 12;
                                const interestAccrued = debt.currentBalance * monthlyInterestRate;
                                const principalPaid = payment.amount - interestAccrued;
                                const newBalance = Math.max(0, debt.currentBalance - principalPaid);
                                
                                const transactionLog = debt.transactionLog || [];
                                const logEntry = {
                                    date: paymentDate.toISOString().split('T')[0],
                                    paymentAmount: payment.amount,
                                    interestAccrued: interestAccrued,
                                    principalPaid: principalPaid,
                                    balanceBefore: debt.currentBalance,
                                    balanceAfter: newBalance
                                };
                                
                                debts[linkedDebtIndex] = {
                                    ...debt,
                                    currentBalance: newBalance,
                                    transactionLog: [...transactionLog, logEntry]
                                };
                            }
                        }
                    }
                });
                
                if (hasChanges) {
                    setTransactions(newTransactions);
                    setPaidPayments(newPaidPayments);
                    setDebts([...debts]); // Save updated debts
                }
            }, [currentMonth]); // Only run on month change, not on every state update

            const getMonthlyTotals = () => {
                const { start, end } = getFinancialMonthRange(currentMonth);
                
                const monthlyTransactions = transactions.filter(t => { const tDate = parseLocalDate(t.date); return tDate >= start && tDate <= end; });
                const income = monthlyTransactions.filter(t => t.type === 'income').reduce((sum, t) => sum + parseFloat(t.amount), 0);
                const expenses = monthlyTransactions.filter(t => t.type === 'expense').reduce((sum, t) => sum + parseFloat(t.amount), 0);
                
                // Total Expenses = ONLY transactions (recurring payments are handled separately)
                return { income, expenses: expenses, net: income - expenses };
            };

            const getTotalDebt = () => debts.reduce((sum, d) => sum + parseFloat(d.currentBalance), 0);

            const getUnpaidRecurring = () => {
                const monthKey = getMonthKey(currentMonth);
                const today = new Date();
                const { start } = getFinancialMonthRange(currentMonth);
                
                return recurringPayments.filter(p => {
                    const isManuallyPaid = paidPayments[`${monthKey}-${p.id}`];
                    if (isManuallyPaid) return false;
                    
                    if (p.auto) {
                        let paymentDate;
                        if (p.dueDay >= 28) {
                            paymentDate = new Date(start.getFullYear(), start.getMonth(), p.dueDay);
                        } else {
                            paymentDate = new Date(start.getFullYear(), start.getMonth() + 1, p.dueDay);
                        }
                        return today < paymentDate;
                    }
                    return true;
                }).reduce((sum, p) => sum + parseFloat(p.amount), 0);
            };

            const exportData = () => {
                const data = {
                    version: "2.0", // Match prod format
                    exportDate: new Date().toISOString(),
                    transactions: transactions.map(t => ({
                        ...t,
                        // Preserve extra fields if they exist
                        month: t.month || parseLocalDate(t.date).getMonth(),
                        year: t.year || parseLocalDate(t.date).getFullYear(),
                        financialMonth: t.financialMonth,
                        financialYear: t.financialYear
                    })),
                    recurringPayments: recurringPayments.map(p => ({
                        ...p,
                        // Include BOTH field names for compatibility
                        day: p.dueDay || p.day, // Prod format
                        dueDay: p.dueDay || p.day, // Beta format
                        varies: p.varies || false // Preserve prod field
                    })),
                    debts: debts.map(d => ({
                        ...d,
                        // Include BOTH field names for compatibility
                        balance: d.currentBalance || d.balance, // Prod format
                        currentBalance: d.currentBalance || d.balance, // Beta format
                        apr: d.interestRate || d.apr, // Prod format
                        interestRate: d.interestRate || d.apr, // Beta format
                        payment: d.minimumPayment || d.payment, // Prod format
                        minimumPayment: d.minimumPayment || d.payment, // Beta format
                        // Preserve extra prod fields if they exist
                        dueDay: d.dueDay,
                        lastUpdated: d.lastUpdated,
                        recurringPaymentId: d.recurringPaymentId
                    })),
                    paidPayments: paidPayments
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `finance-tracker-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
            };

            const importData = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            
                            // Import transactions - preserve all fields
                            if (data.transactions) { 
                                const validTransactions = data.transactions.map(t => ({ 
                                    ...t, // Preserve ALL fields
                                    amount: parseFloat(t.amount) || 0, 
                                    id: t.id || (Date.now() + Math.random()) 
                                })); 
                                setTransactions(validTransactions); 
                            }
                            
                            // Import recurring payments - handle both formats
                            if (data.recurringPayments) { 
                                const validPayments = data.recurringPayments.map(p => ({ 
                                    ...p, // Preserve ALL fields (including varies, etc.)
                                    name: p.name, 
                                    amount: parseFloat(p.amount) || 0, 
                                    category: p.category || '', 
                                    dueDay: parseInt(p.dueDay || p.day) || 1, // Accept both formats
                                    day: parseInt(p.day || p.dueDay) || 1, // Preserve prod format
                                    linkedDebt: p.linkedDebt || '', 
                                    auto: p.auto || false, 
                                    varies: p.varies || false, // Preserve prod field
                                    id: p.id || (Date.now() + Math.random())
                                })); 
                                setRecurringPayments(validPayments);
                                
                                // Load existing paid payments from export
                                const monthKey = getMonthKey(currentMonth);
                                const today = new Date();
                                const { start } = getFinancialMonthRange(currentMonth);
                                const newPaidPayments = {...(data.paidPayments || {})};
                                
                                // Additionally mark auto-pay items as paid if due date has passed
                                validPayments.forEach(p => {
                                    if (p.auto) {
                                        let paymentDate;
                                        if (p.dueDay >= 28) {
                                            paymentDate = new Date(start.getFullYear(), start.getMonth(), p.dueDay);
                                        } else {
                                            paymentDate = new Date(start.getFullYear(), start.getMonth() + 1, p.dueDay);
                                        }
                                        if (today >= paymentDate) {
                                            newPaidPayments[`${monthKey}-${p.id}`] = true;
                                        }
                                    }
                                });
                                setPaidPayments(newPaidPayments);
                            }
                            
                            // Import debts - handle both formats
                            if (data.debts) { 
                                const validDebts = data.debts.map(d => { 
                                    const currentBalance = parseFloat(d.currentBalance || d.balance) || 0; 
                                    const originalBalance = parseFloat(d.originalBalance) || currentBalance; 
                                    const interestRate = parseFloat(d.interestRate || d.apr) || 0;
                                    const minimumPayment = parseFloat(d.minimumPayment || d.payment) || 0;
                                    
                                    return { 
                                        ...d, // Preserve ALL fields (dueDay, lastUpdated, recurringPaymentId, etc.)
                                        name: d.name, 
                                        originalBalance: originalBalance, 
                                        currentBalance: currentBalance, 
                                        balance: currentBalance, // Preserve prod format
                                        interestRate: interestRate, 
                                        apr: interestRate, // Preserve prod format
                                        minimumPayment: minimumPayment, 
                                        payment: minimumPayment, // Preserve prod format
                                        category: d.category || 'Other', 
                                        id: d.id || (Date.now() + Math.random()) 
                                    }; 
                                }); 
                                setDebts(validDebts); 
                            }
                            
                            if (data.paidPayments && !data.recurringPayments) setPaidPayments(data.paidPayments);
                            alert('Data imported successfully!');
                        } catch (error) { alert('Error importing data. Please check the file format.\n\nError: ' + error.message); }
                    };
                    reader.readAsText(file);
                }
                event.target.value = '';
            };

            const clearAllData = () => {
                if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
                    setTransactions([]);
                    setRecurringPayments([]);
                    setDebts([]);
                    setPaidPayments({});
                    localStorage.clear();
                }
            };

            const totals = getMonthlyTotals();
            const totalDebt = getTotalDebt();
            const unpaidRecurring = getUnpaidRecurring();

            return (
                <div className="app-container">
                    <div className="header">
                        <h1>üí∞ Finance Tracker</h1>
                        <div className="version">v1.8.4 | Custom Category Option in Add Transaction</div>
                    </div>
                    <div className="tab-navigation">
                        <button className={`tab-button ${activeTab === 'dashboard' ? 'active' : ''}`} onClick={() => setActiveTab('dashboard')}>üìä Dashboard</button>
                        <button className={`tab-button ${activeTab === 'transactions' ? 'active' : ''}`} onClick={() => setActiveTab('transactions')}>üí≥ Transactions</button>
                        <button className={`tab-button ${activeTab === 'recurring' ? 'active' : ''}`} onClick={() => setActiveTab('recurring')}>üîÑ Recurring</button>
                        <button className={`tab-button ${activeTab === 'debts' ? 'active' : ''}`} onClick={() => setActiveTab('debts')}>üìâ Debt Tracking</button>
                        <button className={`tab-button ${activeTab === 'payoff' ? 'active' : ''}`} onClick={() => setActiveTab('payoff')}>üéØ Payoff Strategies</button>
                        <button className={`tab-button ${activeTab === 'settings' ? 'active' : ''}`} onClick={() => setActiveTab('settings')}>‚öôÔ∏è Settings</button>
                    </div>
                    <div className="tab-content">
                        {activeTab === 'dashboard' && <DashboardTab totals={totals} totalDebt={totalDebt} unpaidRecurring={unpaidRecurring} currentMonth={currentMonth} transactions={transactions} recurringPayments={recurringPayments} debts={debts} />}
                        {activeTab === 'transactions' && <TransactionsTab transactions={transactions} setTransactions={setTransactions} currentMonth={currentMonth} expenseCategories={expenseCategories} incomeCategories={incomeCategories} />}
                        {activeTab === 'recurring' && <RecurringTab recurringPayments={recurringPayments} setRecurringPayments={setRecurringPayments} debts={debts} setDebts={setDebts} transactions={transactions} setTransactions={setTransactions} paidPayments={paidPayments} setPaidPayments={setPaidPayments} currentMonth={currentMonth} />}
                        {activeTab === 'debts' && <DebtsTab debts={debts} setDebts={setDebts} />}
                        {activeTab === 'payoff' && <PayoffStrategiesTab debts={debts} />}
                        {activeTab === 'settings' && <SettingsTab exportData={exportData} importData={importData} clearAllData={clearAllData} />}
                    </div>
                </div>
            );
        }

        function DashboardTab({ totals, totalDebt, unpaidRecurring, currentMonth, transactions, recurringPayments, debts }) {
            const monthName = currentMonth.toLocaleString('default', { month: 'long', year: 'numeric' });
            const { start, end } = getFinancialMonthRange(currentMonth);
            const getYearlyTotals = () => {
                const currentYear = new Date().getFullYear();
                const yearlyTransactions = transactions.filter(t => { const tDate = parseLocalDate(t.date); return tDate.getFullYear() === currentYear; });
                const income = yearlyTransactions.filter(t => t.type === 'income').reduce((sum, t) => sum + parseFloat(t.amount), 0);
                const expenses = yearlyTransactions.filter(t => t.type === 'expense').reduce((sum, t) => sum + parseFloat(t.amount), 0);
                return { income, expenses, net: income - expenses, year: currentYear };
            };
            const yearlyTotals = getYearlyTotals();

            return (
                <div>
                    <div className="yearly-overview income"><h2>üìà Total Income {yearlyTotals.year}</h2><div className="amount">{formatCurrency(yearlyTotals.income)}</div></div>
                    <div className="yearly-overview expense"><h2>üìâ Total Expenses {yearlyTotals.year}</h2><div className="amount">{formatCurrency(yearlyTotals.expenses)}</div></div>
                    <div className="yearly-overview net"><h2>üí∞ Net {yearlyTotals.year}</h2><div className={`amount ${yearlyTotals.net >= 0 ? 'positive' : 'negative'}`}>{formatCurrency(yearlyTotals.net)}</div></div>
                    <h2 style={{color: '#667eea', marginBottom: '20px', marginTop: '40px'}}>Current Month: {monthName}</h2>
                    <p style={{color: '#a0aec0', marginBottom: '20px'}}>Period: {start.toLocaleDateString()} - {end.toLocaleDateString()}</p>
                    <div className="summary-grid">
                        <div className="summary-card"><h3>Total Income</h3><div className="amount">{formatCurrency(totals.income)}</div></div>
                        <div className="summary-card"><h3>Total Expenses</h3><div className="amount">{formatCurrency(totals.expenses)}</div><div className="subtitle">From transactions only</div></div>
                        <div className="summary-card"><h3>Net Balance</h3><div className="amount">{formatCurrency(totals.net)}</div><div className="subtitle">{totals.income > 0 ? ((totals.net / totals.income) * 100).toFixed(1) : 0}% of income</div></div>
                        <div className="summary-card"><h3>Unpaid Recurring</h3><div className="amount">{formatCurrency(unpaidRecurring)}</div><div className="subtitle">Still due this month</div></div>
                    </div>
                    {transactions.length > 0 && (
                        <div className="section">
                            <h2>Recent Transactions</h2>
                            <div className="transaction-list">
                                {transactions.slice().sort((a, b) => new Date(b.date) - new Date(a.date)).slice(0, 5).map(t => (
                                    <div key={t.id} className={`transaction-item ${t.type}`}>
                                        <div className="item-details">
                                            <h4>{t.description}</h4>
                                            <p>{t.category} ‚Ä¢ {t.date}</p>
                                        </div>
                                        <div className={`item-amount ${t.type === 'income' ? 'positive' : 'negative'}`}>
                                            {t.type === 'income' ? '+' : '-'}{formatCurrency(parseFloat(t.amount))}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                    {debts.length > 0 && (
                        <div className="section">
                            <h2>Debt Overview</h2>
                            <div className="debt-overview-grid">
                                {debts.map(debt => {
                                    const originalBalance = parseFloat(debt.originalBalance) || 0;
                                    const currentBalance = parseFloat(debt.currentBalance) || 0;
                                    const interestRate = parseFloat(debt.interestRate) || 0;
                                    const progressPercent = originalBalance > 0 ? ((originalBalance - currentBalance) / originalBalance * 100) : 0;
                                    return (
                                        <div key={debt.id} className="debt-mini-card">
                                            <h4>{debt.name}</h4>
                                            <div className="debt-amount">{formatCurrency(currentBalance)}</div>
                                            <div className="debt-info">{debt.category}</div>
                                            <div className="debt-info">{interestRate.toFixed(2)}% APR</div>
                                            <div className="progress-bar" style={{marginTop: '8px'}}><div className="progress-fill" style={{width: `${Math.min(progressPercent, 100)}%`}}></div></div>
                                            <div className="debt-info" style={{marginTop: '5px'}}>{progressPercent.toFixed(1)}% paid off</div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        function TransactionsTab({ transactions, setTransactions, currentMonth, expenseCategories, incomeCategories }) {
            const [formData, setFormData] = useState({ type: 'expense', amount: '', description: '', category: '', date: new Date().toISOString().split('T')[0] });
            const [expandedMonths, setExpandedMonths] = useState({});
            const [selectedCategory, setSelectedCategory] = useState('All');
            const [editingTransaction, setEditingTransaction] = useState(null);
            const [showCustomCategory, setShowCustomCategory] = useState(false);
            const [customCategory, setCustomCategory] = useState('');

            const handleSubmit = (e) => {
                e.preventDefault();
                if (formData.amount && formData.description) {
                    const finalCategory = showCustomCategory ? customCategory : formData.category;
                    if (!finalCategory) {
                        alert('Please select or enter a category');
                        return;
                    }
                    setTransactions([...transactions, { ...formData, category: finalCategory, amount: parseFloat(formData.amount), id: Date.now() }]);
                    setFormData({ type: 'expense', amount: '', description: '', category: '', date: new Date().toISOString().split('T')[0] });
                    setShowCustomCategory(false);
                    setCustomCategory('');
                }
            };

            const handleEdit = (transaction) => {
                setEditingTransaction(transaction);
            };

            const handleUpdate = (updatedTransaction) => {
                setTransactions(transactions.map(t => t.id === updatedTransaction.id ? updatedTransaction : t));
                setEditingTransaction(null);
            };

            const deleteTransaction = (id) => setTransactions(transactions.filter(t => t.id !== id));
            const toggleMonth = (monthKey) => setExpandedMonths(prev => ({ ...prev, [monthKey]: !prev[monthKey] }));
            const getAllCategories = () => { const categories = new Set(); transactions.forEach(t => { if (t.category) categories.add(t.category); }); return ['All', ...Array.from(categories).sort()]; };
            const filterTransactionsByCategory = (transactionsList) => selectedCategory === 'All' ? transactionsList : transactionsList.filter(t => t.category === selectedCategory);
            const groupTransactionsByMonth = () => {
                const grouped = {};
                const filteredTransactions = filterTransactionsByCategory(transactions);
                filteredTransactions.forEach(transaction => {
                    const date = parseLocalDate(transaction.date);
                    const day = date.getDate();
                    let financialMonth, financialYear;
                    if (day >= 28) { financialMonth = date.getMonth() + 1; financialYear = date.getFullYear(); if (financialMonth > 11) { financialMonth = 0; financialYear++; } } else { financialMonth = date.getMonth(); financialYear = date.getFullYear(); }
                    const monthKey = `${financialYear}-${String(financialMonth + 1).padStart(2, '0')}`;
                    const monthLabel = new Date(financialYear, financialMonth, 1).toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                    if (!grouped[monthKey]) { grouped[monthKey] = { label: monthLabel, transactions: [], income: 0, expenses: 0 }; }
                    grouped[monthKey].transactions.push(transaction);
                    const amount = parseFloat(transaction.amount) || 0;
                    if (transaction.type === 'income') { grouped[monthKey].income += amount; } else { grouped[monthKey].expenses += amount; }
                });
                return Object.entries(grouped).sort((a, b) => b[0].localeCompare(a[0]));
            };

            const categories = getAllCategories();
            const monthlyGroups = groupTransactionsByMonth();

            return (
                <div>
                    <div className="section">
                        <h2>Add New Transaction</h2>
                        <form onSubmit={handleSubmit}>
                            <div className="form-row">
                                <div className="form-group"><label>Type</label><select value={formData.type} onChange={(e) => setFormData({...formData, type: e.target.value})}><option value="income">Income</option><option value="expense">Expense</option></select></div>
                                <div className="form-group"><label>Amount</label><input type="number" step="0.01" value={formData.amount} onChange={(e) => setFormData({...formData, amount: e.target.value})} placeholder="0.00" required /></div>
                                <div className="form-group"><label>Date</label><input type="date" value={formData.date} onChange={(e) => setFormData({...formData, date: e.target.value})} required /></div>
                            </div>
                            <div className="form-row">
                                <div className="form-group"><label>Description</label><input type="text" value={formData.description} onChange={(e) => setFormData({...formData, description: e.target.value})} placeholder="e.g., Grocery shopping" required /></div>
                                <div className="form-group">
                                    <label>Category</label>
                                    <select 
                                        value={showCustomCategory ? 'custom' : formData.category} 
                                        onChange={(e) => {
                                            if (e.target.value === 'custom') {
                                                setShowCustomCategory(true);
                                                setFormData({...formData, category: ''});
                                            } else {
                                                setShowCustomCategory(false);
                                                setCustomCategory('');
                                                setFormData({...formData, category: e.target.value});
                                            }
                                        }} 
                                        required={!showCustomCategory}
                                    >
                                        <option value="">Select category</option>
                                        {(formData.type === 'expense' ? expenseCategories : incomeCategories).map(cat => 
                                            <option key={cat} value={cat}>{cat}</option>
                                        )}
                                        <option value="custom">+ Custom Category</option>
                                    </select>
                                </div>
                                {showCustomCategory && (
                                    <div className="form-group">
                                        <label>Custom Category</label>
                                        <input 
                                            type="text" 
                                            value={customCategory} 
                                            onChange={(e) => setCustomCategory(e.target.value)} 
                                            placeholder="Enter category name" 
                                            required 
                                        />
                                    </div>
                                )}
                            </div>
                            <button type="submit">Add Transaction</button>
                        </form>
                    </div>
                    <div className="section">
                        <h2>Transaction History</h2>
                        <div className="category-filters">
                            {categories.map(category => (
                                <button key={category} className={`category-filter-btn ${selectedCategory === category ? 'active' : ''}`} onClick={() => setSelectedCategory(category)}>{category}</button>
                            ))}
                        </div>
                        {monthlyGroups.length === 0 ? (
                            <p style={{color: '#a0aec0', textAlign: 'center', padding: '20px'}}>No transactions {selectedCategory !== 'All' ? `in category "${selectedCategory}"` : 'yet'}.</p>
                        ) : (
                            monthlyGroups.map(([monthKey, data]) => (
                                <div key={monthKey} className="collapsible-section">
                                    <div className="collapsible-header" onClick={() => toggleMonth(monthKey)}>
                                        <div><h3>{data.label}</h3><p style={{fontSize: '0.9em', marginTop: '5px', opacity: 0.9}}>{data.transactions.length} transaction{data.transactions.length !== 1 ? 's' : ''} ‚Ä¢ Income: {formatCurrency(data.income)} ‚Ä¢ Expenses: {formatCurrency(data.expenses)}</p></div>
                                        <div style={{fontSize: '1.5em'}}>{expandedMonths[monthKey] ? '‚ñº' : '‚ñ∂'}</div>
                                    </div>
                                    {expandedMonths[monthKey] && (
                                        <div className="collapsible-content">
                                            <div className="transaction-list">
                                                {[...data.transactions].sort((a, b) => new Date(b.date) - new Date(a.date)).map((transaction) => (
                                                    <div key={transaction.id} className={`transaction-item ${transaction.type}`}>
                                                        <div className="item-details"><h4>{transaction.description}</h4><p>{transaction.category} ‚Ä¢ {transaction.date}</p></div>
                                                        <div style={{display: 'flex', alignItems: 'center', gap: '15px'}}>
                                                            <div className={`item-amount ${transaction.type === 'income' ? 'positive' : 'negative'}`}>{transaction.type === 'income' ? '+' : '-'}{formatCurrency(Math.abs(parseFloat(transaction.amount) || 0))}</div>
                                                            <button onClick={() => handleEdit(transaction)} style={{padding: '8px 16px', fontSize: '0.9em'}}>Edit</button>
                                                            <button className="danger" onClick={() => deleteTransaction(transaction.id)} style={{padding: '8px 16px', fontSize: '0.9em'}}>Delete</button>
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            ))
                        )}
                    </div>
                    {editingTransaction && <EditTransactionModal transaction={editingTransaction} onUpdate={handleUpdate} onClose={() => setEditingTransaction(null)} />}
                </div>
            );
        }

        function EditTransactionModal({ transaction, onUpdate, onClose }) {
            const [formData, setFormData] = useState({ ...transaction });

            const handleSubmit = (e) => {
                e.preventDefault();
                onUpdate({ ...formData, amount: parseFloat(formData.amount) });
            };

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="modal" onClick={(e) => e.stopPropagation()}>
                        <h2>Edit Transaction</h2>
                        <form onSubmit={handleSubmit}>
                            <div className="form-row">
                                <div className="form-group"><label>Type</label><select value={formData.type} onChange={(e) => setFormData({...formData, type: e.target.value})}><option value="income">Income</option><option value="expense">Expense</option></select></div>
                                <div className="form-group"><label>Amount</label><input type="number" step="0.01" value={formData.amount} onChange={(e) => setFormData({...formData, amount: e.target.value})} required /></div>
                                <div className="form-group"><label>Date</label><input type="date" value={formData.date} onChange={(e) => setFormData({...formData, date: e.target.value})} required /></div>
                            </div>
                            <div className="form-row">
                                <div className="form-group"><label>Description</label><input type="text" value={formData.description} onChange={(e) => setFormData({...formData, description: e.target.value})} required /></div>
                                <div className="form-group"><label>Category</label><input type="text" value={formData.category} onChange={(e) => setFormData({...formData, category: e.target.value})} /></div>
                            </div>
                            <div style={{display: 'flex', gap: '10px', marginTop: '20px'}}>
                                <button type="submit">Save Changes</button>
                                <button type="button" className="secondary" onClick={onClose}>Cancel</button>
                            </div>
                        </form>
                    </div>
                </div>
            );
        }

        function RecurringTab({ recurringPayments, setRecurringPayments, debts, setDebts, transactions, setTransactions, paidPayments, setPaidPayments, currentMonth }) {
            const [formData, setFormData] = useState({ name: '', amount: '', category: '', dueDay: '1', linkedDebt: '', auto: false });
            const [editingPayment, setEditingPayment] = useState(null);
            const monthKey = getMonthKey(currentMonth);

            // Check if auto-pay should be marked as paid (due date has passed in financial month)
            const shouldAutoPayBePaid = (payment) => {
                if (!payment.auto) return false;
                const today = new Date();
                const currentDay = today.getDate();
                const { start } = getFinancialMonthRange(currentMonth);
                
                // Create a date for the payment due day in the financial month
                let paymentDate;
                if (payment.dueDay >= 28) {
                    // Days 28-31 are at the START of the financial month (previous calendar month)
                    paymentDate = new Date(start.getFullYear(), start.getMonth(), payment.dueDay);
                } else {
                    // Days 1-27 are in the NEXT calendar month after start
                    paymentDate = new Date(start.getFullYear(), start.getMonth() + 1, payment.dueDay);
                }
                
                // Payment is paid if today >= payment date
                return today >= paymentDate;
            };

            const handleSubmit = (e) => { 
                e.preventDefault(); 
                if (formData.name && formData.amount) { 
                    const newPayment = { ...formData, amount: parseFloat(formData.amount), dueDay: parseInt(formData.dueDay), id: Date.now() };
                    setRecurringPayments([...recurringPayments, newPayment]); 
                    
                    // Auto-pay: mark as paid if due date has already passed this month
                    if (formData.auto && shouldAutoPayBePaid(newPayment)) {
                        const paymentKey = `${monthKey}-${newPayment.id}`;
                        setPaidPayments({...paidPayments, [paymentKey]: true});
                    }
                    
                    setFormData({ name: '', amount: '', category: '', dueDay: '1', linkedDebt: '', auto: false }); 
                } 
            };

            const deletePayment = (id) => setRecurringPayments(recurringPayments.filter(p => p.id !== id));
            
            const handleEdit = (payment) => {
                setEditingPayment(payment);
            };

            const handleUpdate = (updatedPayment) => {
                setRecurringPayments(recurringPayments.map(p => p.id === updatedPayment.id ? updatedPayment : p));
                setEditingPayment(null);
            };
            
            const processPayment = (payment) => {
                console.log('Processing payment:', payment.name);
                console.log('Linked debt ID:', payment.linkedDebt);
                
                const paymentKey = `${monthKey}-${payment.id}`;
                const newTransaction = { type: 'expense', amount: payment.amount, description: `${payment.name} (Recurring)`, category: payment.category, date: new Date().toISOString().split('T')[0], id: Date.now() };
                setTransactions([...transactions, newTransaction]);
                setPaidPayments({...paidPayments, [paymentKey]: true});
                
                if (payment.linkedDebt) {
                    console.log('Payment has linked debt, processing...');
                    setDebts(debts.map(debt => { 
                        if (debt.id === parseInt(payment.linkedDebt)) {
                            console.log('Found matching debt:', debt.name);
                            const interestRate = parseFloat(debt.interestRate) || 0;
                            const monthlyInterestRate = interestRate / 100 / 12;
                            const interestAccrued = debt.currentBalance * monthlyInterestRate;
                            const principalPaid = payment.amount - interestAccrued;
                            const newBalance = Math.max(0, debt.currentBalance - principalPaid);
                            
                            const transactionLog = debt.transactionLog || [];
                            const logEntry = {
                                date: new Date().toISOString().split('T')[0],
                                paymentAmount: payment.amount,
                                interestAccrued: interestAccrued,
                                principalPaid: principalPaid,
                                balanceBefore: debt.currentBalance,
                                balanceAfter: newBalance
                            };
                            
                            console.log('Creating log entry:', logEntry);
                            console.log('Transaction log length before:', transactionLog.length);
                            console.log('Transaction log length after:', transactionLog.length + 1);
                            
                            return { 
                                ...debt, 
                                currentBalance: newBalance,
                                transactionLog: [...transactionLog, logEntry]
                            }; 
                        } 
                        return debt; 
                    })); 
                }
                alert(`Payment processed: ${payment.name} for ${formatCurrency(payment.amount)}`);
            };

            const togglePaidStatus = (paymentId) => {
                const paymentKey = `${monthKey}-${paymentId}`;
                setPaidPayments({...paidPayments, [paymentKey]: !paidPayments[paymentKey]});
            };

            return (
                <div>
                    <div className="section">
                        <h2>Add Recurring Payment</h2>
                        <form onSubmit={handleSubmit}>
                            <div className="form-row">
                                <div className="form-group"><label>Payment Name</label><input type="text" value={formData.name} onChange={(e) => setFormData({...formData, name: e.target.value})} placeholder="e.g., Mortgage, Netflix" required /></div>
                                <div className="form-group"><label>Amount</label><input type="number" step="0.01" value={formData.amount} onChange={(e) => setFormData({...formData, amount: e.target.value})} placeholder="0.00" required /></div>
                            </div>
                            <div className="form-row">
                                <div className="form-group"><label>Category</label><input type="text" value={formData.category} onChange={(e) => setFormData({...formData, category: e.target.value})} placeholder="e.g., Housing, Entertainment" /></div>
                                <div className="form-group"><label>Due Day (1-31)</label><input type="number" min="1" max="31" value={formData.dueDay} onChange={(e) => setFormData({...formData, dueDay: e.target.value})} required /></div>
                                <div className="form-group"><label>Link to Debt (Optional)</label><select value={formData.linkedDebt} onChange={(e) => setFormData({...formData, linkedDebt: e.target.value})}><option value="">None</option>{debts.map(debt => (<option key={debt.id} value={debt.id}>{debt.name}</option>))}</select></div>
                            </div>
                            <div className="form-group" style={{marginBottom: '0'}}>
                                <label style={{display: 'flex', alignItems: 'center', cursor: 'pointer'}}>
                                    <input type="checkbox" checked={formData.auto} onChange={(e) => setFormData({...formData, auto: e.target.checked})} style={{width: 'auto', marginRight: '10px'}} />
                                    Auto-pay (mark as paid when due date passes)
                                </label>
                            </div>
                            <button type="submit" style={{marginTop: '20px'}}>Add Recurring Payment</button>
                        </form>
                    </div>
                    <div className="section">
                        <h2>Recurring Payments ({recurringPayments.length})</h2>
                        <p style={{color: '#a0aec0', marginBottom: '15px', fontSize: '1.1em'}}>
                            Total Monthly: <strong style={{color: '#667eea'}}>{formatCurrency(recurringPayments.reduce((sum, p) => sum + parseFloat(p.amount), 0))}</strong>
                        </p>
                        <div className="payment-list">
                            {recurringPayments.length === 0 ? (
                                <p style={{color: '#a0aec0', textAlign: 'center', padding: '20px'}}>No recurring payments yet.</p>
                            ) : (
                                recurringPayments.sort((a, b) => a.dueDay - b.dueDay).map((payment) => {
                                    const linkedDebt = payment.linkedDebt ? debts.find(d => d.id === parseInt(payment.linkedDebt)) : null;
                                    const isManuallyPaid = paidPayments[`${monthKey}-${payment.id}`];
                                    const isAutoPaid = payment.auto && shouldAutoPayBePaid(payment);
                                    const isPaid = isManuallyPaid || isAutoPaid;
                                    
                                    return (
                                        <div key={payment.id} className={`payment-item ${isPaid ? 'paid' : 'unpaid'}`}>
                                            <div className="item-details">
                                                <h4>
                                                    {payment.name}
                                                    {isPaid && <span className="paid-badge">‚úì Paid</span>}
                                                    {payment.auto ? <span className="auto-badge">AUTO</span> : <span className="manual-badge">MANUAL</span>}
                                                </h4>
                                                <p>{payment.category} ‚Ä¢ Due: Day {payment.dueDay}{linkedDebt && ` ‚Ä¢ Linked to: ${linkedDebt.name}`}</p>
                                            </div>
                                            <div style={{display: 'flex', alignItems: 'center', gap: '15px'}}>
                                                <div className="item-amount negative">{formatCurrency(payment.amount)}</div>
                                                {!isPaid && !payment.auto && <button onClick={() => processPayment(payment)} style={{padding: '8px 16px', fontSize: '0.9em'}}>Process</button>}
                                                {!payment.auto && <button className={isPaid ? 'secondary' : 'success'} onClick={() => togglePaidStatus(payment.id)} style={{padding: '8px 16px', fontSize: '0.9em'}}>{isPaid ? 'Mark Unpaid' : 'Mark Paid'}</button>}
                                                <button onClick={() => handleEdit(payment)} style={{padding: '8px 16px', fontSize: '0.9em'}}>Edit</button>
                                                <button className="danger" onClick={() => deletePayment(payment.id)} style={{padding: '8px 16px', fontSize: '0.9em'}}>Delete</button>
                                            </div>
                                        </div>
                                    );
                                })
                            )}
                        </div>
                    </div>
                    {editingPayment && <EditRecurringPaymentModal payment={editingPayment} onUpdate={handleUpdate} onClose={() => setEditingPayment(null)} debts={debts} />}
                </div>
            );
        }

        function EditRecurringPaymentModal({ payment, onUpdate, onClose, debts }) {
            const [formData, setFormData] = useState({ ...payment });

            const handleSubmit = (e) => {
                e.preventDefault();
                onUpdate({ ...formData, amount: parseFloat(formData.amount), dueDay: parseInt(formData.dueDay) });
            };

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="modal" onClick={(e) => e.stopPropagation()}>
                        <h2>Edit Recurring Payment</h2>
                        <form onSubmit={handleSubmit}>
                            <div className="form-row">
                                <div className="form-group"><label>Payment Name</label><input type="text" value={formData.name} onChange={(e) => setFormData({...formData, name: e.target.value})} required /></div>
                                <div className="form-group"><label>Amount</label><input type="number" step="0.01" value={formData.amount} onChange={(e) => setFormData({...formData, amount: e.target.value})} required /></div>
                            </div>
                            <div className="form-row">
                                <div className="form-group"><label>Category</label><input type="text" value={formData.category} onChange={(e) => setFormData({...formData, category: e.target.value})} /></div>
                                <div className="form-group"><label>Due Day (1-31)</label><input type="number" min="1" max="31" value={formData.dueDay} onChange={(e) => setFormData({...formData, dueDay: e.target.value})} required /></div>
                                <div className="form-group"><label>Link to Debt</label><select value={formData.linkedDebt || ''} onChange={(e) => setFormData({...formData, linkedDebt: e.target.value})}><option value="">None</option>{debts.map(debt => (<option key={debt.id} value={debt.id}>{debt.name}</option>))}</select></div>
                            </div>
                            <div className="form-group" style={{marginBottom: '0'}}>
                                <label style={{display: 'flex', alignItems: 'center', cursor: 'pointer'}}>
                                    <input type="checkbox" checked={formData.auto || false} onChange={(e) => setFormData({...formData, auto: e.target.checked})} style={{width: 'auto', marginRight: '10px'}} />
                                    Auto-pay
                                </label>
                            </div>
                            <div style={{display: 'flex', gap: '10px', marginTop: '20px'}}>
                                <button type="submit">Save Changes</button>
                                <button type="button" className="secondary" onClick={onClose}>Cancel</button>
                            </div>
                        </form>
                    </div>
                </div>
            );
        }

        function DebtsTab({ debts, setDebts }) {
            const [formData, setFormData] = useState({ name: '', originalBalance: '', currentBalance: '', interestRate: '', minimumPayment: '', category: 'Credit Card' });
            const [expandedDebt, setExpandedDebt] = useState(null);
            const handleSubmit = (e) => { e.preventDefault(); if (formData.name && formData.currentBalance) { setDebts([...debts, { ...formData, originalBalance: parseFloat(formData.originalBalance) || parseFloat(formData.currentBalance), currentBalance: parseFloat(formData.currentBalance), interestRate: parseFloat(formData.interestRate) || 0, minimumPayment: parseFloat(formData.minimumPayment) || 0, id: Date.now() }]); setFormData({ name: '', originalBalance: '', currentBalance: '', interestRate: '', minimumPayment: '', category: 'Credit Card' }); } };
            const deleteDebt = (id) => setDebts(debts.filter(d => d.id !== id));
            const calculatePayoffMonths = (debt) => { if (debt.minimumPayment <= 0 || debt.currentBalance <= 0) return 'N/A'; const monthlyRate = (debt.interestRate / 100) / 12; let balance = debt.currentBalance; let months = 0; while (balance > 0 && months < 600) { const interest = balance * monthlyRate; const principal = debt.minimumPayment - interest; if (principal <= 0) return '‚àû (payment < interest)'; balance -= principal; months++; } return months; };
            const formatPayoffDate = (months) => { if (months === 'N/A' || typeof months === 'string') return months; const today = new Date(); const payoffDate = new Date(today.getFullYear(), today.getMonth() + months, today.getDate()); return payoffDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' }); };

            return (
                <div>
                    <div className="section">
                        <h2>Add New Debt</h2>
                        <form onSubmit={handleSubmit}>
                            <div className="form-row">
                                <div className="form-group"><label>Debt Name</label><input type="text" value={formData.name} onChange={(e) => setFormData({...formData, name: e.target.value})} placeholder="e.g., Visa Card, Car Loan" required /></div>
                                <div className="form-group"><label>Category</label><select value={formData.category} onChange={(e) => setFormData({...formData, category: e.target.value})}><option value="Credit Card">Credit Card</option><option value="Auto Loan">Auto Loan</option><option value="Mortgage">Mortgage</option><option value="Personal Loan">Personal Loan</option><option value="Student Loan">Student Loan</option><option value="Other">Other</option></select></div>
                            </div>
                            <div className="form-row">
                                <div className="form-group"><label>Original Balance</label><input type="number" step="0.01" value={formData.originalBalance} onChange={(e) => setFormData({...formData, originalBalance: e.target.value})} placeholder="0.00" /></div>
                                <div className="form-group"><label>Current Balance</label><input type="number" step="0.01" value={formData.currentBalance} onChange={(e) => setFormData({...formData, currentBalance: e.target.value})} placeholder="0.00" required /></div>
                                <div className="form-group"><label>Interest Rate (%)</label><input type="number" step="0.01" value={formData.interestRate} onChange={(e) => setFormData({...formData, interestRate: e.target.value})} placeholder="0.00" /></div>
                                <div className="form-group"><label>Minimum Payment</label><input type="number" step="0.01" value={formData.minimumPayment} onChange={(e) => setFormData({...formData, minimumPayment: e.target.value})} placeholder="0.00" /></div>
                            </div>
                            <button type="submit">Add Debt</button>
                        </form>
                    </div>
                    <div className="section">
                        <h2>Active Debts ({debts.length})</h2>
                        <p style={{color: '#a0aec0', marginBottom: '15px', fontSize: '1.1em'}}>
                            Total Debt: <strong style={{color: '#dc3545'}}>{formatCurrency(debts.reduce((sum, d) => sum + parseFloat(d.currentBalance), 0))}</strong>
                        </p>
                        <div className="debt-list">
                            {debts.length === 0 ? (
                                <p style={{color: '#a0aec0', textAlign: 'center', padding: '20px'}}>No debts tracked yet.</p>
                            ) : (
                                debts.map((debt) => {
                                    const payoffMonths = calculatePayoffMonths(debt);
                                    const payoffDate = formatPayoffDate(payoffMonths);
                                    const progressPercent = debt.originalBalance > 0 ? ((debt.originalBalance - debt.currentBalance) / debt.originalBalance * 100) : 0;
                                    return (
                                        <div key={debt.id} className="collapsible-section">
                                            <div className="collapsible-header" onClick={() => setExpandedDebt(expandedDebt === debt.id ? null : debt.id)}>
                                                <div><h3>{debt.name}</h3><p style={{fontSize: '0.9em', marginTop: '5px', opacity: 0.9}}>{debt.category} ‚Ä¢ Balance: {formatCurrency(debt.currentBalance)}</p></div>
                                                <div style={{fontSize: '1.5em'}}>{expandedDebt === debt.id ? '‚ñº' : '‚ñ∂'}</div>
                                            </div>
                                            {expandedDebt === debt.id && (
                                                <div className="collapsible-content">
                                                    <div className="debt-details">
                                                        <div className="debt-detail-item"><label>Original Balance</label><div className="value">{formatCurrency(debt.originalBalance)}</div></div>
                                                        <div className="debt-detail-item"><label>Current Balance</label><div className="value">{formatCurrency(debt.currentBalance)}</div></div>
                                                        <div className="debt-detail-item"><label>Interest Rate</label><div className="value">{debt.interestRate.toFixed(2)}%</div></div>
                                                        <div className="debt-detail-item"><label>Minimum Payment</label><div className="value">{formatCurrency(debt.minimumPayment)}</div></div>
                                                        <div className="debt-detail-item"><label>Payoff Timeline</label><div className="value">{typeof payoffMonths === 'number' ? `${payoffMonths} months` : payoffMonths}</div></div>
                                                        <div className="debt-detail-item"><label>Projected Payoff</label><div className="value">{payoffDate}</div></div>
                                                    </div>
                                                    <div style={{marginTop: '15px'}}>
                                                        <label style={{display: 'block', marginBottom: '8px', fontSize: '0.9em'}}>Progress: {progressPercent.toFixed(1)}% paid off</label>
                                                        <div className="progress-bar"><div className="progress-fill" style={{width: `${Math.min(progressPercent, 100)}%`}}></div></div>
                                                    </div>
                                                    {debt.transactionLog && debt.transactionLog.length > 0 && (
                                                        <div style={{marginTop: '20px'}}>
                                                            <h4 style={{color: '#667eea', marginBottom: '10px'}}>Transaction History</h4>
                                                            <div style={{maxHeight: '300px', overflowY: 'auto'}}>
                                                                {debt.transactionLog.slice().reverse().map((log, index) => (
                                                                    <div key={index} style={{background: '#1a1f2e', padding: '12px', borderRadius: '8px', marginBottom: '8px', fontSize: '0.9em'}}>
                                                                        <div style={{display: 'flex', justifyContent: 'space-between', marginBottom: '5px'}}>
                                                                            <span style={{color: '#a0aec0'}}>Date:</span>
                                                                            <span style={{color: '#e2e8f0', fontWeight: '600'}}>{new Date(log.date).toLocaleDateString()}</span>
                                                                        </div>
                                                                        <div style={{display: 'flex', justifyContent: 'space-between', marginBottom: '5px'}}>
                                                                            <span style={{color: '#a0aec0'}}>Payment:</span>
                                                                            <span style={{color: '#28a745', fontWeight: '600'}}>{formatCurrency(log.paymentAmount)}</span>
                                                                        </div>
                                                                        <div style={{display: 'flex', justifyContent: 'space-between', marginBottom: '5px'}}>
                                                                            <span style={{color: '#a0aec0'}}>Interest Accrued:</span>
                                                                            <span style={{color: '#dc3545', fontWeight: '600'}}>{formatCurrency(log.interestAccrued)}</span>
                                                                        </div>
                                                                        <div style={{display: 'flex', justifyContent: 'space-between', marginBottom: '5px'}}>
                                                                            <span style={{color: '#a0aec0'}}>Principal Paid:</span>
                                                                            <span style={{color: '#667eea', fontWeight: '600'}}>{formatCurrency(log.principalPaid)}</span>
                                                                        </div>
                                                                        <div style={{display: 'flex', justifyContent: 'space-between', paddingTop: '8px', borderTop: '1px solid #2d3748'}}>
                                                                            <span style={{color: '#a0aec0'}}>Balance:</span>
                                                                            <span style={{color: '#e2e8f0', fontWeight: '600'}}>{formatCurrency(log.balanceBefore)} ‚Üí {formatCurrency(log.balanceAfter)}</span>
                                                                        </div>
                                                                    </div>
                                                                ))}
                                                            </div>
                                                        </div>
                                                    )}
                                                    <div style={{marginTop: '20px', display: 'flex', gap: '10px'}}>
                                                        <button className="danger" onClick={() => deleteDebt(debt.id)}>Delete Debt</button>
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    );
                                })
                            )}
                        </div>
                    </div>
                </div>
            );
        }

        function PayoffStrategiesTab({ debts }) {
            const [extraPayment, setExtraPayment] = useState(0);
            const [selectedStrategy, setSelectedStrategy] = useState('snowball');
            const calculatePayoffOrder = (sortedDebts) => {
                const timeline = []; let currentMonth = 0; let totalInterest = 0; let remainingDebts = sortedDebts.map(d => ({ ...d })); const extra = parseFloat(extraPayment) || 0;
                while (remainingDebts.length > 0) {
                    let availableExtra = extra;
                    remainingDebts = remainingDebts.filter(debt => {
                        const monthlyRate = (debt.interestRate / 100) / 12; const interest = debt.currentBalance * monthlyRate; totalInterest += interest;
                        let payment = debt.minimumPayment; if (debt === remainingDebts[0]) { payment += availableExtra; }
                        const principal = payment - interest; debt.currentBalance -= principal;
                        if (debt.currentBalance <= 0) { timeline.push({ name: debt.name, month: currentMonth, category: debt.category }); return false; }
                        return true;
                    });
                    currentMonth++; if (currentMonth > 600) break;
                }
                return { timeline, totalMonths: currentMonth, totalInterest };
            };
            const calculateSnowball = () => { const sortedDebts = [...debts].map(d => ({ ...d, currentBalance: parseFloat(d.currentBalance), minimumPayment: parseFloat(d.minimumPayment), interestRate: parseFloat(d.interestRate) })).sort((a, b) => a.currentBalance - b.currentBalance); return calculatePayoffOrder(sortedDebts); };
            const calculateAvalanche = () => { const sortedDebts = [...debts].map(d => ({ ...d, currentBalance: parseFloat(d.currentBalance), minimumPayment: parseFloat(d.minimumPayment), interestRate: parseFloat(d.interestRate) })).sort((a, b) => b.interestRate - a.interestRate); return calculatePayoffOrder(sortedDebts); };
            const snowballResult = calculateSnowball(); const avalancheResult = calculateAvalanche(); const activeResult = selectedStrategy === 'snowball' ? snowballResult : avalancheResult;
            const formatMonth = (monthNum) => { const date = new Date(); date.setMonth(date.getMonth() + monthNum); return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' }); };

            return (
                <div>
                    <div className="section">
                        <h2>üéØ Debt Payoff Strategies</h2>
                        <p style={{color: '#a0aec0', lineHeight: '1.6', marginBottom: '20px'}}>Compare two popular debt payoff strategies to find the best approach for your situation.</p>
                        <div className="form-row" style={{marginBottom: '20px'}}>
                            <div className="form-group"><label>Extra Monthly Payment</label><input type="number" step="0.01" value={extraPayment} onChange={(e) => setExtraPayment(e.target.value)} placeholder="0.00" /></div>
                            <div className="form-group"><label>View Strategy</label><select value={selectedStrategy} onChange={(e) => setSelectedStrategy(e.target.value)}><option value="snowball">Debt Snowball</option><option value="avalanche">Debt Avalanche</option></select></div>
                        </div>
                    </div>
                    {debts.length === 0 ? (
                        <div className="section"><p style={{color: '#a0aec0', textAlign: 'center', padding: '40px'}}>No debts to analyze. Add debts in the Debt Tracking tab to see payoff strategies.</p></div>
                    ) : (
                        <>
                            <div className="dashboard-grid">
                                <div className="section"><h2>‚ùÑÔ∏è Debt Snowball</h2><p style={{color: '#a0aec0', fontSize: '0.9em', marginBottom: '15px'}}>Pay off smallest balances first for psychological wins</p><div style={{fontSize: '2em', fontWeight: '700', color: '#667eea', marginBottom: '5px'}}>{snowballResult.totalMonths} months</div><div style={{color: '#a0aec0', fontSize: '0.9em'}}>Total Interest: {formatCurrency(snowballResult.totalInterest)}</div><div style={{color: '#a0aec0', fontSize: '0.9em'}}>Debt-Free: {formatMonth(snowballResult.totalMonths)}</div></div>
                                <div className="section"><h2>‚õ∞Ô∏è Debt Avalanche</h2><p style={{color: '#a0aec0', fontSize: '0.9em', marginBottom: '15px'}}>Pay off highest interest rates first to save money</p><div style={{fontSize: '2em', fontWeight: '700', color: '#667eea', marginBottom: '5px'}}>{avalancheResult.totalMonths} months</div><div style={{color: '#a0aec0', fontSize: '0.9em'}}>Total Interest: {formatCurrency(avalancheResult.totalInterest)}</div><div style={{color: '#a0aec0', fontSize: '0.9em'}}>Debt-Free: {formatMonth(avalancheResult.totalMonths)}</div>{avalancheResult.totalInterest < snowballResult.totalInterest && (<div style={{background: '#28a745', color: 'white', padding: '10px', borderRadius: '5px', fontSize: '0.85em', textAlign: 'center', marginTop: '10px'}}>üí∞ Saves {formatCurrency(snowballResult.totalInterest - avalancheResult.totalInterest)} in interest</div>)}</div>
                            </div>
                            <div className="section">
                                <h2>{selectedStrategy === 'snowball' ? '‚ùÑÔ∏è Snowball' : '‚õ∞Ô∏è Avalanche'} Payoff Timeline</h2>
                                <div style={{marginTop: '20px'}}>
                                    {activeResult.timeline.map((item, index) => (
                                        <div key={index} style={{background: '#1a1f2e', padding: '15px 20px', borderRadius: '8px', marginBottom: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', borderLeft: '4px solid #28a745'}}>
                                            <div><h4 style={{color: '#e2e8f0', marginBottom: '5px'}}>{item.name}</h4><p style={{color: '#a0aec0', fontSize: '0.85em'}}>{item.category}</p></div>
                                            <div style={{textAlign: 'right'}}><div style={{color: '#28a745', fontWeight: '700', fontSize: '1.1em'}}>Month {item.month}</div><div style={{color: '#a0aec0', fontSize: '0.85em'}}>{formatMonth(item.month)}</div></div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </>
                    )}
                </div>
            );
        }

        function SettingsTab({ exportData, importData, clearAllData }) {
            return (
                <div>
                    <div className="section">
                        <h2>Data Management</h2>
                        <div className="controls">
                            <button onClick={exportData}>üíæ Export Data</button>
                            <label style={{background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', color: 'white', padding: '12px 30px', borderRadius: '8px', cursor: 'pointer', fontWeight: 600, display: 'inline-block'}}>üìÅ Import Data<input type="file" accept=".json" onChange={importData} style={{display: 'none'}} /></label>
                            <button className="danger" onClick={clearAllData}>üóëÔ∏è Clear All Data</button>
                        </div>
                        <p style={{marginTop: '20px', color: '#a0aec0', fontSize: '0.9em'}}>Export your data to save a backup, import previously exported data, or clear all data to start fresh.</p>
                    </div>
                    <div className="section">
                        <h2>About</h2>
                        <p style={{marginBottom: '15px', lineHeight: '1.6', color: '#e2e8f0'}}><strong>Finance Tracker v1.7.7</strong></p>
                        <p style={{marginBottom: '10px', lineHeight: '1.6', color: '#a0aec0'}}>A comprehensive personal finance management tool with full backward/forward compatibility between production and beta versions.</p>
                        
                        <h3 style={{marginTop: '20px', marginBottom: '10px', color: '#667eea'}}>v1.7.7 - Full Compatibility:</h3>
                        <ul style={{lineHeight: '1.8', color: '#a0aec0', marginLeft: '20px'}}>
                            <li>‚úÖ <strong>Bidirectional field names</strong> - Exports include both old (day, balance, apr, payment) and new (dueDay, currentBalance, interestRate, minimumPayment) formats</li>
                            <li>‚úÖ <strong>Zero data loss</strong> - Preserves ALL fields from both prod and beta (varies, financialMonth, dueDay, lastUpdated, recurringPaymentId, etc.)</li>
                            <li>‚úÖ <strong>Round-trip safe</strong> - Prod ‚Üí Beta ‚Üí Prod or Beta ‚Üí Prod ‚Üí Beta maintains all data</li>
                            <li>‚úÖ <strong>Version field</strong> - Exports include version: "2.0" matching prod format</li>
                            <li>‚úÖ <strong>Import handles both formats</strong> - Accepts day OR dueDay, balance OR currentBalance, etc.</li>
                        </ul>
                        
                        <h3 style={{marginTop: '20px', marginBottom: '10px', color: '#667eea'}}>Compatibility Guarantee:</h3>
                        <ul style={{lineHeight: '1.8', color: '#a0aec0', marginLeft: '20px'}}>
                            <li>üì¶ Export from v1.1.0 prod ‚Üí Import to v1.7.7 beta = ‚úì Works perfectly</li>
                            <li>üì¶ Export from v1.7.7 beta ‚Üí Import to v1.1.0 prod = ‚úì Works perfectly</li>
                            <li>üì¶ Export from v1.7.7 ‚Üí Import to v1.7.7 = ‚úì Perfect preservation</li>
                            <li>üíæ All extra fields preserved across versions</li>
                            <li>üîÑ Test in beta, sync to prod anytime without data loss</li>
                        </ul>
                        
                        <h3 style={{marginTop: '20px', marginBottom: '10px', color: '#667eea'}}>Previous Features:</h3>
                        <ul style={{lineHeight: '1.8', color: '#a0aec0', marginLeft: '20px'}}>
                            <li>Auto-transaction creation for auto-pay items</li>
                            <li>Edit transactions and recurring payments</li>
                            <li>Smart duplicate detection (requires ALL words + category + amount)</li>
                            <li>Payment tracking (paid/unpaid status per month)</li>
                            <li>Financial month grouping (28th-27th cycle)</li>
                            <li>Debt payoff strategies (Snowball & Avalanche)</li>
                            <li>Dark mode interface</li>
                        </ul>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<FinanceTracker />, document.getElementById('root'));
    </script>
</body>
</html>
