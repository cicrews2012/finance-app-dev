<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Finance Tracker v1.11.11</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); min-height: 100vh; padding: 20px; }
        #root { max-width: 1400px; margin: 0 auto; }
        .app-container { background: #0f1419; border-radius: 20px; box-shadow: 0 20px 60px rgba(0,0,0,0.5); overflow: hidden; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; font-weight: 700; }
        .header .version { font-size: 0.9em; opacity: 0.9; }
        .tab-navigation { display: flex; background: #1a1f2e; border-bottom: 2px solid #2d3748; overflow-x: auto; }
        .tab-button { flex: 1; min-width: 150px; padding: 18px 24px; background: transparent; border: none; cursor: pointer; font-size: 1em; font-weight: 600; color: #a0aec0; transition: all 0.3s ease; border-bottom: 3px solid transparent; }
        .tab-button:hover { background: #2d3748; color: #e2e8f0; }
        .tab-button.active { color: #667eea; border-bottom-color: #667eea; background: #0f1419; }
        .tab-content { padding: 30px; background: #0f1419; }
        .yearly-overview { background: #1a1f2e; padding: 40px; border-radius: 15px; margin-bottom: 30px; text-align: center; }
        .yearly-overview h2 { color: #a0aec0; font-size: 1.2em; margin-bottom: 15px; text-transform: uppercase; letter-spacing: 2px; }
        .yearly-overview .amount { font-size: 3.5em; font-weight: 700; margin-bottom: 10px; }
        .yearly-overview.income .amount { color: #28a745; }
        .yearly-overview.expense .amount { color: #dc3545; }
        .yearly-overview.net .amount.positive { color: #28a745; }
        .yearly-overview.net .amount.negative { color: #dc3545; }
        .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .summary-card { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 25px; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
        .summary-card h3 { font-size: 0.9em; opacity: 0.9; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; }
        .summary-card .amount { font-size: 2em; font-weight: 700; }
        .summary-card .subtitle { font-size: 0.85em; opacity: 0.85; margin-top: 8px; }
        .section { background: #1a1f2e; padding: 25px; border-radius: 15px; margin-bottom: 20px; }
        .section h2 { color: #667eea; margin-bottom: 20px; font-size: 1.5em; }
        .category-filters { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; }
        .category-filter-btn { background: #2d3748; color: #a0aec0; border: 2px solid transparent; padding: 10px 20px; border-radius: 25px; font-size: 0.9em; font-weight: 600; cursor: pointer; transition: all 0.3s ease; }
        .category-filter-btn:hover { background: #4a5568; color: #e2e8f0; }
        .category-filter-btn.active { background: #667eea; color: white; border-color: #667eea; }
        .dashboard-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        @media (max-width: 968px) { .dashboard-grid { grid-template-columns: 1fr; } }
        .debt-overview-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 15px; }
        .debt-mini-card { background: #1a1f2e; padding: 18px; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); border-left: 4px solid #ffc107; }
        .debt-mini-card h4 { color: #e2e8f0; margin-bottom: 8px; font-size: 1em; }
        .debt-mini-card .debt-amount { font-size: 1.4em; font-weight: 700; color: #667eea; margin-bottom: 8px; }
        .debt-mini-card .debt-info { font-size: 0.85em; color: #a0aec0; margin-bottom: 4px; }
        .form-group { margin-bottom: 20px; }
        .form-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px; }
        label { display: block; margin-bottom: 8px; color: #a0aec0; font-weight: 600; font-size: 0.9em; }
        input, select { width: 100%; padding: 12px; border: 2px solid #2d3748; border-radius: 8px; font-size: 1em; transition: border-color 0.3s; background: #0f1419; color: #e2e8f0; }
        input:focus, select:focus { outline: none; border-color: #667eea; }
        button { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 12px 30px; border-radius: 8px; font-size: 1em; font-weight: 600; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; }
        button:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4); }
        button:active { transform: translateY(0); }
        button.secondary { background: #6c757d; margin-left: 10px; }
        button.danger { background: #dc3545; }
        button.success { background: #28a745; }
        .transaction-list, .payment-list, .debt-list { margin-top: 20px; }
        .transaction-item, .payment-item, .debt-item { background: #1a1f2e; padding: 20px; border-radius: 10px; margin-bottom: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: flex; justify-content: space-between; align-items: center; }
        .transaction-item.income { border-left: 4px solid #28a745; }
        .transaction-item.expense { border-left: 4px solid #dc3545; }
        .payment-item.paid { opacity: 0.6; border-left: 4px solid #28a745; }
        .payment-item.unpaid { border-left: 4px solid #ffc107; }
        .item-details h4 { color: #e2e8f0; margin-bottom: 5px; }
        .item-details p { color: #a0aec0; font-size: 0.9em; }
        .item-amount { font-size: 1.3em; font-weight: 700; }
        .item-amount.positive { color: #28a745; }
        .item-amount.negative { color: #dc3545; }
        .controls { display: flex; gap: 10px; margin-top: 20px; }
        .collapsible-section { margin-bottom: 15px; }
        .collapsible-header { background: #667eea; color: white; padding: 15px 20px; border-radius: 10px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: background 0.3s; }
        .collapsible-header:hover { background: #5568d3; }
        .collapsible-header h3 { margin: 0; font-size: 1.2em; }
        .collapsible-content { padding: 20px; background: #0f1419; border-radius: 0 0 10px 10px; margin-top: 2px; }
        .debt-item { border-left: 4px solid #ffc107; }
        .progress-bar { width: 100%; height: 8px; background: #2d3748; border-radius: 4px; overflow: hidden; margin-top: 10px; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #28a745, #20c997); transition: width 0.3s ease; }
        .debt-details { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-top: 15px; font-size: 0.9em; }
        .debt-detail-item { padding: 10px; background: #1a1f2e; border-radius: 5px; }
        .debt-detail-item label { font-size: 0.8em; color: #a0aec0; margin-bottom: 5px; }
        .debt-detail-item .value { font-weight: 700; color: #e2e8f0; }
        .paid-badge { background: #28a745; color: white; padding: 4px 12px; border-radius: 12px; font-size: 0.8em; font-weight: 600; margin-left: 10px; }
        .auto-badge { background: #17a2b8; color: white; padding: 4px 12px; border-radius: 12px; font-size: 0.8em; font-weight: 600; margin-left: 10px; }
        .manual-badge { background: #6c757d; color: white; padding: 4px 12px; border-radius: 12px; font-size: 0.8em; font-weight: 600; margin-left: 10px; }
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 1000; }
        .modal { background: #1a1f2e; border-radius: 15px; padding: 30px; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto; }
        .modal h2 { color: #667eea; margin-bottom: 20px; }
        .budget-overview { background: linear-gradient(135deg, #28a74522 0%, #20c99722 100%); border: 2px solid #28a745; padding: 30px; border-radius: 15px; margin-bottom: 30px; }
        .budget-row { display: flex; justify-content: space-between; align-items: center; padding: 12px 0; border-bottom: 1px solid #2d3748; }
        .budget-row:last-child { border-bottom: none; }
        .budget-row.total { border-top: 3px solid #667eea; padding-top: 20px; margin-top: 15px; font-size: 1.3em; font-weight: 700; }
        .budget-label { color: #a0aec0; font-size: 1.1em; }
        .budget-label.total { color: #e2e8f0; }
        .budget-value { font-size: 1.3em; font-weight: 700; color: #e2e8f0; }
        .budget-value.positive { color: #28a745; }
        .budget-value.negative { color: #dc3545; }
        .budget-value.warning { color: #ffc107; }
        .income-input-group { display: flex; gap: 15px; align-items: flex-end; margin-bottom: 30px; }
        .income-input-group .form-group { flex: 1; margin-bottom: 0; }
        @media (max-width: 768px) { .tab-navigation { flex-wrap: wrap; } .tab-button { flex: 1 1 50%; } .summary-grid { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const formatCurrency = (amount) => new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 2, maximumFractionDigits: 2 }).format(amount);
        const parseLocalDate = (dateStr) => { const [year, month, day] = dateStr.split('-').map(Number); return new Date(year, month - 1, day); };
        const getLocalDateString = (date = new Date()) => {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        };
        const getCurrentFinancialMonth = () => { const today = new Date(); const day = today.getDate(); const month = today.getMonth(); const year = today.getFullYear(); if (day >= 28) { return new Date(year, month + 1, 1); } else { return new Date(year, month, 1); } };
        const getFinancialMonthRange = (date) => { const month = date.getMonth(); const year = date.getFullYear(); const start = new Date(year, month - 1, 28); const end = new Date(year, month, 27, 23, 59, 59); return { start, end }; };
        const getMonthKey = (date) => { const d = new Date(date); return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`; };

        function FinanceTracker() {
            // Predefined categories
            const expenseCategories = ['Food', 'Groceries', 'Subscriptions', 'Home', 'Car Payments', 'Personal', 'Pets', 'Utilities', 'Gas (cars)', 'Debt', 'Insurance', 'Kids', 'Savings', 'House cleaning', 'Entertainment', 'Healthcare', 'Transportation', 'Other'];
            const incomeCategories = ['Salary', 'Freelance', 'Investment', 'Gift', 'Bonus', 'Refund', 'Other'];
            
            const [activeTab, setActiveTab] = useState('dashboard');
            const [transactions, setTransactions] = useState([]);
            const [recurringPayments, setRecurringPayments] = useState([]);
            const [debts, setDebts] = useState([]);
            const [paidPayments, setPaidPayments] = useState({});
            const [currentMonth, setCurrentMonth] = useState(getCurrentFinancialMonth());
            const [expectedMonthlyIncome, setExpectedMonthlyIncome] = useState(5000);

            useEffect(() => {
                // No localStorage - app starts empty
                // Data must be imported via Import button
            }, []);

            // No auto-save - use Export button to save data
            // No auto-save - use Export button to save data

            // Auto-process recurring payments when their due date passes
            useEffect(() => {
                // Run immediately when data loads or month changes
                const timer = setTimeout(() => {
                    if (recurringPayments.length === 0) return;
                    
                    console.log('üöÄ AUTO-PAY SYSTEM RUNNING');
                    console.log('Current month:', currentMonth);
                    console.log('Transactions before:', transactions.length);
                    console.log('Recurring payments:', recurringPayments.length);
                    
                    const monthKey = getMonthKey(currentMonth);
                    const todayDate = new Date();
                    const { start } = getFinancialMonthRange(currentMonth);
                    
                    let newTransactions = [...transactions];
                    let updatedDebts = [...debts];
                    let hasTransactionChanges = false;
                    let hasDebtChanges = false;
                    
                    recurringPayments.forEach(payment => {
                        console.log(`\n--- Checking ${payment.name} ---`);
                        
                        // Skip if not auto-pay
                        if (!payment.auto) {
                            console.log('  Skipped: Not auto-pay');
                            return;
                        }
                        
                        // Calculate payment date
                        let paymentDate;
                        if (payment.dueDay >= 28) {
                            paymentDate = new Date(start.getFullYear(), start.getMonth(), payment.dueDay);
                        } else {
                            paymentDate = new Date(start.getFullYear(), start.getMonth() + 1, payment.dueDay);
                        }
                        
                        console.log('  Payment date:', paymentDate.toDateString());
                        console.log('  Today:', todayDate.toDateString());
                        console.log('  Due date passed:', todayDate >= paymentDate);
                        
                        // Check if due date has passed
                        if (todayDate >= paymentDate) {
                            const paymentKey = `${monthKey}-${payment.id}`;
                            
                            // Check if transaction already exists for this payment (simple check)
                            const transactionExists = newTransactions.some(t => {
                                // Must be expense in current financial month with matching amount
                                if (t.type !== 'expense') return false;
                                
                                const tDate = parseLocalDate(t.date);
                                const endDate = new Date(start.getFullYear(), start.getMonth() + 1, 27);
                                if (tDate < start || tDate > endDate) return false;
                                
                                // Amount must match within $0.01
                                if (Math.abs(parseFloat(t.amount) - parseFloat(payment.amount)) > 0.01) return false;
                                
                                // Description must contain payment name OR category must match
                                const descMatch = t.description.toLowerCase().includes(payment.name.toLowerCase());
                                const catMatch = payment.category && t.category && 
                                                t.category.toLowerCase() === payment.category.toLowerCase();
                                
                                return descMatch || catMatch;
                            });
                            
                            console.log('  Transaction exists:', transactionExists);
                            
                            // Create transaction if it doesn't exist
                            if (!transactionExists) {
                                console.log('  ‚úÖ CREATING TRANSACTION');
                                const newTransaction = {
                                    type: 'expense',
                                    amount: parseFloat(payment.amount),
                                    description: `${payment.name} (Auto)`,
                                    category: payment.category,
                                    date: getLocalDateString(paymentDate),
                                    id: Date.now() + Math.random(),
                                    isRecurring: true
                                };
                                newTransactions.push(newTransaction);
                                console.log('  Created transaction:', newTransaction);
                                hasTransactionChanges = true;
                                
                                // Update linked debt if exists and transaction was created
                                if (payment.linkedDebt) {
                                    console.log('  Updating linked debt:', payment.linkedDebt);
                                    const linkedDebtIndex = updatedDebts.findIndex(d => d.id === parseInt(payment.linkedDebt));
                                    if (linkedDebtIndex !== -1) {
                                        const debt = updatedDebts[linkedDebtIndex];
                                        const interestRate = parseFloat(debt.interestRate) || 0;
                                        const monthlyInterestRate = interestRate / 100 / 12;
                                        const interestAccrued = debt.currentBalance * monthlyInterestRate;
                                        const principalPaid = payment.amount - interestAccrued;
                                        const newBalance = Math.max(0, debt.currentBalance - principalPaid);
                                        
                                        const transactionLog = debt.transactionLog || [];
                                        const logEntry = {
                                            date: getLocalDateString(paymentDate),
                                            paymentAmount: payment.amount,
                                            interestAccrued: interestAccrued,
                                            principalPaid: principalPaid,
                                            balanceBefore: debt.currentBalance,
                                            balanceAfter: newBalance
                                        };
                                        
                                        updatedDebts[linkedDebtIndex] = {
                                            ...debt,
                                            currentBalance: newBalance,
                                            transactionLog: [...transactionLog, logEntry]
                                        };
                                        console.log('  Debt updated:', updatedDebts[linkedDebtIndex].name);
                                        hasDebtChanges = true;
                                    }
                                }
                            }
                            
                            // Mark as paid using functional form to preserve manual toggles
                            setPaidPayments(prevPaid => {
                                // Only update if not already paid
                                if (!prevPaid[paymentKey]) {
                                    console.log('  Marking as paid');
                                    return {...prevPaid, [paymentKey]: true};
                                }
                                console.log('  Already marked paid:', prevPaid[paymentKey]);
                                return prevPaid;
                            });
                        }
                    });
                    
                    console.log('\n--- Summary ---');
                    console.log('Has transaction changes:', hasTransactionChanges);
                    console.log('Has debt changes:', hasDebtChanges);
                    console.log('New transactions count:', newTransactions.length);
                    console.log('Transactions added:', newTransactions.length - transactions.length);
                    
                    if (hasTransactionChanges) {
                        console.log('üíæ Saving transactions to state');
                        setTransactions(newTransactions);
                    }
                    
                    if (hasDebtChanges) {
                        console.log('üíæ Saving debts to state');
                        setDebts(updatedDebts);
                    }
                }, 500); // Wait 500ms for data to load
                
                return () => clearTimeout(timer);
            }, [currentMonth, recurringPayments.length]); // Run when month changes or payments added/removed

            const getMonthlyTotals = () => {
                const { start, end } = getFinancialMonthRange(currentMonth);
                
                const monthlyTransactions = transactions.filter(t => { const tDate = parseLocalDate(t.date); return tDate >= start && tDate <= end; });
                const income = monthlyTransactions.filter(t => t.type === 'income').reduce((sum, t) => sum + parseFloat(t.amount), 0);
                const expenses = monthlyTransactions.filter(t => t.type === 'expense').reduce((sum, t) => sum + parseFloat(t.amount), 0);
                
                // Total Expenses = ONLY transactions (recurring payments are handled separately)
                return { income, expenses: expenses, net: income - expenses };
            };

            const getTotalDebt = () => debts.reduce((sum, d) => sum + parseFloat(d.currentBalance), 0);

            const getUnpaidRecurring = () => {
                const monthKey = getMonthKey(currentMonth);
                const today = new Date();
                const { start } = getFinancialMonthRange(currentMonth);
                
                return recurringPayments.filter(p => {
                    const isManuallyPaid = paidPayments[`${monthKey}-${p.id}`];
                    if (isManuallyPaid) return false;
                    
                    if (p.auto) {
                        let paymentDate;
                        if (p.dueDay >= 28) {
                            paymentDate = new Date(start.getFullYear(), start.getMonth(), p.dueDay);
                        } else {
                            paymentDate = new Date(start.getFullYear(), start.getMonth() + 1, p.dueDay);
                        }
                        return today < paymentDate;
                    }
                    return true;
                }).reduce((sum, p) => sum + parseFloat(p.amount), 0);
            };

            const exportData = () => {
                const data = {
                    version: "2.0", // Match prod format
                    exportDate: new Date().toISOString(),
                    transactions: transactions.map(t => ({
                        ...t,
                        // Preserve extra fields if they exist
                        month: t.month || parseLocalDate(t.date).getMonth(),
                        year: t.year || parseLocalDate(t.date).getFullYear(),
                        financialMonth: t.financialMonth,
                        financialYear: t.financialYear
                    })),
                    recurringPayments: recurringPayments.map(p => ({
                        ...p,
                        // Include BOTH field names for compatibility
                        day: p.dueDay || p.day, // Prod format
                        dueDay: p.dueDay || p.day, // Beta format
                        varies: p.varies || false // Preserve prod field
                    })),
                    debts: debts.map(d => ({
                        ...d,
                        // Include BOTH field names for compatibility
                        balance: d.currentBalance || d.balance, // Prod format
                        currentBalance: d.currentBalance || d.balance, // Beta format
                        apr: d.interestRate || d.apr, // Prod format
                        interestRate: d.interestRate || d.apr, // Beta format
                        payment: d.minimumPayment || d.payment, // Prod format
                        minimumPayment: d.minimumPayment || d.payment, // Beta format
                        // Preserve extra prod fields if they exist
                        dueDay: d.dueDay,
                        lastUpdated: d.lastUpdated,
                        recurringPaymentId: d.recurringPaymentId
                    })),
                    paidPayments: paidPayments,
                    settings: {
                        expectedMonthlyIncome: expectedMonthlyIncome
                    }
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `finance-tracker-${getLocalDateString()}.json`;
                a.click();
            };

            const importData = (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            
                            // Import transactions - preserve all fields
                            if (data.transactions) { 
                                const validTransactions = data.transactions.map(t => ({ 
                                    ...t, // Preserve ALL fields
                                    amount: parseFloat(t.amount) || 0, 
                                    id: t.id || (Date.now() + Math.random()) 
                                })); 
                                setTransactions(validTransactions); 
                            }
                            
                            // Import recurring payments - handle both formats
                            if (data.recurringPayments) { 
                                const validPayments = data.recurringPayments.map(p => ({ 
                                    ...p, // Preserve ALL fields (including varies, etc.)
                                    name: p.name, 
                                    amount: parseFloat(p.amount) || 0, 
                                    category: p.category || '', 
                                    dueDay: parseInt(p.dueDay || p.day) || 1, // Accept both formats
                                    day: parseInt(p.day || p.dueDay) || 1, // Preserve prod format
                                    linkedDebt: p.linkedDebt || '', 
                                    auto: p.auto || false, 
                                    varies: p.varies || false, // Preserve prod field
                                    id: p.id || (Date.now() + Math.random())
                                })); 
                                setRecurringPayments(validPayments);
                                
                                // Load existing paid payments from export
                                const monthKey = getMonthKey(currentMonth);
                                const today = new Date();
                                const { start } = getFinancialMonthRange(currentMonth);
                                const newPaidPayments = {...(data.paidPayments || {})};
                                
                                // Additionally mark auto-pay items as paid if due date has passed
                                validPayments.forEach(p => {
                                    if (p.auto) {
                                        let paymentDate;
                                        if (p.dueDay >= 28) {
                                            paymentDate = new Date(start.getFullYear(), start.getMonth(), p.dueDay);
                                        } else {
                                            paymentDate = new Date(start.getFullYear(), start.getMonth() + 1, p.dueDay);
                                        }
                                        if (today >= paymentDate) {
                                            newPaidPayments[`${monthKey}-${p.id}`] = true;
                                        }
                                    }
                                });
                                setPaidPayments(newPaidPayments);
                            }
                            
                            // Import debts - handle both formats
                            if (data.debts) { 
                                const validDebts = data.debts.map(d => { 
                                    const currentBalance = parseFloat(d.currentBalance || d.balance) || 0; 
                                    const originalBalance = parseFloat(d.originalBalance) || currentBalance; 
                                    const interestRate = parseFloat(d.interestRate || d.apr) || 0;
                                    const minimumPayment = parseFloat(d.minimumPayment || d.payment) || 0;
                                    
                                    return { 
                                        ...d, // Preserve ALL fields (dueDay, lastUpdated, recurringPaymentId, etc.)
                                        name: d.name, 
                                        originalBalance: originalBalance, 
                                        currentBalance: currentBalance, 
                                        balance: currentBalance, // Preserve prod format
                                        interestRate: interestRate, 
                                        apr: interestRate, // Preserve prod format
                                        minimumPayment: minimumPayment, 
                                        payment: minimumPayment, // Preserve prod format
                                        category: d.category || 'Other', 
                                        id: d.id || (Date.now() + Math.random()) 
                                    }; 
                                }); 
                                setDebts(validDebts); 
                            }
                            
                            if (data.paidPayments && !data.recurringPayments) setPaidPayments(data.paidPayments);
                            
                            // Import settings
                            if (data.settings && data.settings.expectedMonthlyIncome) {
                                setExpectedMonthlyIncome(data.settings.expectedMonthlyIncome);
                            }
                            
                            alert('Data imported successfully!');
                        } catch (error) { alert('Error importing data. Please check the file format.\n\nError: ' + error.message); }
                    };
                    reader.readAsText(file);
                }
                event.target.value = '';
            };

            const clearAllData = () => {
                if (confirm('Are you sure you want to clear all data? This cannot be undone. Make sure you have exported your data first!')) {
                    setTransactions([]);
                    setRecurringPayments([]);
                    setDebts([]);
                    setPaidPayments({});
                    setExpectedMonthlyIncome(5000);
                }
            };

            const totals = getMonthlyTotals();
            const totalDebt = getTotalDebt();
            const unpaidRecurring = getUnpaidRecurring();

            return (
                <div className="app-container">
                    <div className="header">
                        <h1>üí∞ Finance Tracker</h1>
                        <div className="version">v1.11.11 | Manual Debt Payments + Edit Debts</div>
                    </div>
                    <div className="tab-navigation">
                        <button className={`tab-button ${activeTab === 'dashboard' ? 'active' : ''}`} onClick={() => setActiveTab('dashboard')}>üìä Dashboard</button>
                        <button className={`tab-button ${activeTab === 'budget' ? 'active' : ''}`} onClick={() => setActiveTab('budget')}>üíµ Budget</button>
                        <button className={`tab-button ${activeTab === 'transactions' ? 'active' : ''}`} onClick={() => setActiveTab('transactions')}>üí≥ Transactions</button>
                        <button className={`tab-button ${activeTab === 'recurring' ? 'active' : ''}`} onClick={() => setActiveTab('recurring')}>üîÑ Recurring</button>
                        <button className={`tab-button ${activeTab === 'debts' ? 'active' : ''}`} onClick={() => setActiveTab('debts')}>üìâ Debt Tracking</button>
                        <button className={`tab-button ${activeTab === 'payoff' ? 'active' : ''}`} onClick={() => setActiveTab('payoff')}>üéØ Payoff Strategies</button>
                        <button className={`tab-button ${activeTab === 'settings' ? 'active' : ''}`} onClick={() => setActiveTab('settings')}>‚öôÔ∏è Settings</button>
                    </div>
                    <div className="tab-content">
                        {activeTab === 'dashboard' && <DashboardTab totals={totals} totalDebt={totalDebt} unpaidRecurring={unpaidRecurring} currentMonth={currentMonth} transactions={transactions} recurringPayments={recurringPayments} debts={debts} expectedMonthlyIncome={expectedMonthlyIncome} importData={importData} />}
                        {activeTab === 'budget' && <BudgetTab transactions={transactions} recurringPayments={recurringPayments} expectedMonthlyIncome={expectedMonthlyIncome} setExpectedMonthlyIncome={setExpectedMonthlyIncome} currentMonth={currentMonth} unpaidRecurring={unpaidRecurring} />}
                        {activeTab === 'transactions' && <TransactionsTab transactions={transactions} setTransactions={setTransactions} currentMonth={currentMonth} expenseCategories={expenseCategories} incomeCategories={incomeCategories} debts={debts} setDebts={setDebts} />}
                        {activeTab === 'recurring' && <RecurringTab recurringPayments={recurringPayments} setRecurringPayments={setRecurringPayments} debts={debts} setDebts={setDebts} transactions={transactions} setTransactions={setTransactions} paidPayments={paidPayments} setPaidPayments={setPaidPayments} currentMonth={currentMonth} />}
                        {activeTab === 'debts' && <DebtsTab debts={debts} setDebts={setDebts} />}
                        {activeTab === 'payoff' && <PayoffStrategiesTab debts={debts} />}
                        {activeTab === 'settings' && <SettingsTab exportData={exportData} importData={importData} clearAllData={clearAllData} />}
                    </div>
                </div>
            );
        }

        function DashboardTab({ totals, totalDebt, unpaidRecurring, currentMonth, transactions, recurringPayments, debts, expectedMonthlyIncome, importData }) {
            const [debtsCollapsed, setDebtsCollapsed] = useState(false);
            const [selectedYear, setSelectedYear] = useState(new Date().getFullYear());
            const fileInputRef = React.useRef(null); // Move ref to top level
            const monthName = currentMonth.toLocaleString('default', { month: 'long', year: 'numeric' });
            const { start, end } = getFinancialMonthRange(currentMonth);
            
            // Get available years from transactions
            const availableYears = [...new Set(transactions.map(t => {
                const tDate = parseLocalDate(t.date);
                return tDate.getFullYear();
            }))].sort((a, b) => b - a); // Sort descending
            
            // Add current year if not in list
            const currentYear = new Date().getFullYear();
            if (!availableYears.includes(currentYear)) {
                availableYears.unshift(currentYear);
            }
            
            // Simple Money Available calculation
            // Income - Recurring = Money Left
            const recurringTotal = recurringPayments
                .filter(p => {
                    let paymentDate;
                    if (p.dueDay >= 28) {
                        paymentDate = new Date(start.getFullYear(), start.getMonth(), p.dueDay);
                    } else {
                        paymentDate = new Date(start.getFullYear(), start.getMonth() + 1, p.dueDay);
                    }
                    return paymentDate >= start && paymentDate <= end;
                })
                .reduce((sum, p) => sum + parseFloat(p.amount), 0);
            
            const moneyLeft = expectedMonthlyIncome - recurringTotal;
            
            // Total Expenses - Recurring = Spent So Far
            const spentSoFar = totals.expenses - recurringTotal;
            
            // Money Available = Money Left - Spent So Far - Unpaid Recurring (guaranteed to come out)
            const moneyAvailable = moneyLeft - spentSoFar - unpaidRecurring;
            
            const getYearlyTotals = () => {
                const yearlyTransactions = transactions.filter(t => { const tDate = parseLocalDate(t.date); return tDate.getFullYear() === selectedYear; });
                const income = yearlyTransactions.filter(t => t.type === 'income').reduce((sum, t) => sum + parseFloat(t.amount), 0);
                const expenses = yearlyTransactions.filter(t => t.type === 'expense').reduce((sum, t) => sum + parseFloat(t.amount), 0);
                return { income, expenses, net: income - expenses, year: selectedYear };
            };
            const yearlyTotals = getYearlyTotals();

            // Show welcome message if no data loaded
            if (transactions.length === 0 && recurringPayments.length === 0 && debts.length === 0) {
                return (
                    <div>
                        <div style={{textAlign: 'center', padding: '60px 20px', background: '#1a1f2e', borderRadius: '15px', margin: '40px auto', maxWidth: '600px'}}>
                            <h2 style={{color: '#667eea', fontSize: '2em', marginBottom: '20px'}}>üëã Welcome to Finance Tracker!</h2>
                            <p style={{color: '#a0aec0', fontSize: '1.1em', lineHeight: '1.8', marginBottom: '30px'}}>
                                Your finance tracker starts empty. To begin tracking your finances, you'll need to import your data.
                            </p>
                            <div style={{background: '#0f1419', padding: '30px', borderRadius: '10px', textAlign: 'left'}}>
                                <h3 style={{color: '#667eea', marginBottom: '15px'}}>üì• To Get Started:</h3>
                                <ol style={{color: '#e2e8f0', lineHeight: '2', marginLeft: '20px'}}>
                                    <li>Click <strong style={{color: '#28a745'}}>Import Data</strong> below</li>
                                    <li>Select your finance data JSON file</li>
                                    <li>Your dashboard will populate with all your data!</li>
                                </ol>
                            </div>
                            <input 
                                ref={fileInputRef}
                                type="file" 
                                accept=".json" 
                                onChange={importData} 
                                style={{display: 'none'}} 
                            />
                            <button 
                                onClick={() => fileInputRef.current?.click()}
                                style={{
                                    marginTop: '30px',
                                    padding: '15px 40px',
                                    fontSize: '1.1em',
                                    background: 'linear-gradient(135deg, #28a745 0%, #20c997 100%)',
                                    border: 'none',
                                    borderRadius: '10px',
                                    color: 'white',
                                    fontWeight: '700',
                                    cursor: 'pointer',
                                    transition: 'transform 0.2s, box-shadow 0.2s'
                                }}
                                onMouseOver={(e) => {
                                    e.currentTarget.style.transform = 'translateY(-2px)';
                                    e.currentTarget.style.boxShadow = '0 4px 12px rgba(40, 167, 69, 0.4)';
                                }}
                                onMouseOut={(e) => {
                                    e.currentTarget.style.transform = 'translateY(0)';
                                    e.currentTarget.style.boxShadow = 'none';
                                }}
                            >
                                üìÅ Import Data
                            </button>
                            <p style={{color: '#a0aec0', fontSize: '0.9em', marginTop: '30px', fontStyle: 'italic'}}>
                                üí° No localStorage used - all data is managed through JSON import/export
                            </p>
                            <p style={{color: '#667eea', fontSize: '0.95em', marginTop: '15px', fontWeight: '600'}}>
                                üìñ New user? Check the <strong>‚öôÔ∏è Settings</strong> tab for first-time setup instructions!
                            </p>
                        </div>
                    </div>
                );
            }

            return (
                <div>
                    {availableYears.length > 0 && (
                        <div style={{display: 'flex', justifyContent: 'flex-end', marginBottom: '20px', alignItems: 'center', gap: '10px'}}>
                            <label style={{color: '#a0aec0', fontSize: '0.95em'}}>View Year:</label>
                            <select 
                                value={selectedYear} 
                                onChange={(e) => setSelectedYear(parseInt(e.target.value))}
                                style={{padding: '8px 16px', fontSize: '1em', background: '#1a1f2e', color: '#e2e8f0', border: '2px solid #667eea', borderRadius: '8px', cursor: 'pointer'}}
                            >
                                {availableYears.map(year => (
                                    <option key={year} value={year}>{year}</option>
                                ))}
                            </select>
                        </div>
                    )}
                    <div className="yearly-overview income"><h2>üìà Total Income {yearlyTotals.year}</h2><div className="amount">{formatCurrency(yearlyTotals.income)}</div></div>
                    <div className="yearly-overview expense"><h2>üìâ Total Expenses {yearlyTotals.year}</h2><div className="amount">{formatCurrency(yearlyTotals.expenses)}</div></div>
                    <div className="yearly-overview net"><h2>üí∞ Net {yearlyTotals.year}</h2><div className={`amount ${yearlyTotals.net >= 0 ? 'positive' : 'negative'}`}>{formatCurrency(yearlyTotals.net)}</div></div>
                    <h2 style={{color: '#667eea', marginBottom: '20px', marginTop: '40px'}}>Current Month: {monthName}</h2>
                    <p style={{color: '#a0aec0', marginBottom: '20px'}}>Period: {start.toLocaleDateString()} - {end.toLocaleDateString()}</p>
                    <div className="summary-grid">
                        <div className="summary-card"><h3>Total Income</h3><div className="amount">{formatCurrency(totals.income)}</div></div>
                        <div className="summary-card"><h3>Total Expenses</h3><div className="amount">{formatCurrency(totals.expenses)}</div><div className="subtitle">From transactions only</div></div>
                        <div className="summary-card"><h3>Net Balance</h3><div className="amount">{formatCurrency(totals.net)}</div><div className="subtitle">{totals.income > 0 ? ((totals.net / totals.income) * 100).toFixed(1) : 0}% of income</div></div>
                        <div className="summary-card" style={{background: moneyAvailable >= 0 ? 'linear-gradient(135deg, #28a745 0%, #20c997 100%)' : 'linear-gradient(135deg, #dc3545 0%, #c92a2a 100%)'}}><h3>üí∞ Money Available</h3><div className="amount">{formatCurrency(moneyAvailable)}</div><div className="subtitle">After bills & spending<br/><span style={{fontSize: '0.85em', opacity: 0.8}}>(Based on expected income)</span></div></div>
                        <div className="summary-card"><h3>Unpaid Recurring</h3><div className="amount">{formatCurrency(unpaidRecurring)}</div><div className="subtitle">Still due this month</div></div>
                    </div>
                    {transactions.length > 0 && (
                        <div className="section">
                            <h2>Recent Transactions</h2>
                            <div className="transaction-list">
                                {transactions.slice().sort((a, b) => new Date(b.date) - new Date(a.date)).slice(0, 5).map(t => (
                                    <div key={t.id} className={`transaction-item ${t.type}`}>
                                        <div className="item-details">
                                            <h4>{t.description}</h4>
                                            <p>{t.category} ‚Ä¢ {t.date}</p>
                                        </div>
                                        <div className={`item-amount ${t.type === 'income' ? 'positive' : 'negative'}`}>
                                            {t.type === 'income' ? '+' : '-'}{formatCurrency(parseFloat(t.amount))}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                    {transactions.filter(t => {
                        const tDate = parseLocalDate(t.date);
                        return tDate >= start && tDate <= end && t.type === 'expense';
                    }).length > 0 && (
                        <div className="section">
                            <h2>üí≥ Spending by Category This Month</h2>
                            <div style={{marginTop: '20px'}}>
                                {(() => {
                                    const categoryTotals = {};
                                    transactions.filter(t => {
                                        const tDate = parseLocalDate(t.date);
                                        return tDate >= start && tDate <= end && t.type === 'expense';
                                    }).forEach(t => {
                                        categoryTotals[t.category] = (categoryTotals[t.category] || 0) + parseFloat(t.amount);
                                    });
                                    
                                    const totalSpent = Object.values(categoryTotals).reduce((sum, val) => sum + val, 0);
                                    const sortedCategories = Object.entries(categoryTotals).sort((a, b) => b[1] - a[1]).slice(0, 8);
                                    
                                    return sortedCategories.map(([category, amount]) => {
                                        const percentage = (amount / totalSpent) * 100;
                                        return (
                                            <div key={category} style={{marginBottom: '15px'}}>
                                                <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '5px'}}>
                                                    <span style={{color: '#e2e8f0', fontWeight: '600'}}>{category}</span>
                                                    <span style={{color: '#667eea', fontWeight: '700', fontSize: '1.1em'}}>{formatCurrency(amount)}</span>
                                                </div>
                                                <div style={{display: 'flex', alignItems: 'center', gap: '10px'}}>
                                                    <div style={{flex: 1, height: '12px', background: '#2d3748', borderRadius: '6px', overflow: 'hidden'}}>
                                                        <div style={{width: `${percentage}%`, height: '100%', background: 'linear-gradient(90deg, #667eea, #764ba2)', transition: 'width 0.3s ease'}}></div>
                                                    </div>
                                                    <span style={{color: '#a0aec0', fontSize: '0.9em', minWidth: '45px', textAlign: 'right'}}>{percentage.toFixed(1)}%</span>
                                                </div>
                                            </div>
                                        );
                                    });
                                })()}
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        function TransactionsTab({ transactions, setTransactions, currentMonth, expenseCategories, incomeCategories, debts, setDebts }) {
            const [formData, setFormData] = useState({ type: 'expense', amount: '', description: '', category: '', date: getLocalDateString(), linkedDebt: '' });
            const [expandedMonths, setExpandedMonths] = useState({});
            const [selectedCategory, setSelectedCategory] = useState('All');
            const [searchPlace, setSearchPlace] = useState('');
            const [editingTransaction, setEditingTransaction] = useState(null);
            const [showCustomCategory, setShowCustomCategory] = useState(false);
            const [customCategory, setCustomCategory] = useState('');
            const [showBulkEntry, setShowBulkEntry] = useState(false);
            const [bulkRows, setBulkRows] = useState([
                { id: 1, date: getLocalDateString(), description: '', amount: '', category: '', type: 'expense' },
                { id: 2, date: getLocalDateString(), description: '', amount: '', category: '', type: 'expense' },
                { id: 3, date: getLocalDateString(), description: '', amount: '', category: '', type: 'expense' }
            ]);

            const handleSubmit = (e) => {
                e.preventDefault();
                if (formData.amount && formData.description) {
                    const finalCategory = showCustomCategory ? customCategory : formData.category;
                    if (!finalCategory) {
                        alert('Please select or enter a category');
                        return;
                    }
                    
                    const newTransaction = { 
                        ...formData, 
                        category: finalCategory, 
                        amount: parseFloat(formData.amount), 
                        id: Date.now() 
                    };
                    
                    setTransactions([...transactions, newTransaction]);
                    
                    // If linked to debt, update debt balance with interest calculation
                    if (formData.linkedDebt && formData.type === 'expense') {
                        const debtIndex = debts.findIndex(d => d.id === parseInt(formData.linkedDebt));
                        if (debtIndex !== -1) {
                            const debt = debts[debtIndex];
                            const paymentAmount = parseFloat(formData.amount);
                            
                            // Calculate interest accrued since last payment
                            const lastPaymentDate = debt.transactionLog && debt.transactionLog.length > 0
                                ? new Date(debt.transactionLog[debt.transactionLog.length - 1].date)
                                : new Date(debt.lastUpdated || formData.date);
                            
                            const currentDate = parseLocalDate(formData.date);
                            const daysSinceLastPayment = Math.max(1, Math.floor((currentDate - lastPaymentDate) / (1000 * 60 * 60 * 24)));
                            
                            const annualRate = parseFloat(debt.interestRate) || 0;
                            const dailyRate = annualRate / 100 / 365;
                            const interestAccrued = debt.currentBalance * dailyRate * daysSinceLastPayment;
                            
                            const principalPaid = Math.max(0, paymentAmount - interestAccrued);
                            const newBalance = Math.max(0, debt.currentBalance - principalPaid);
                            
                            const transactionLog = debt.transactionLog || [];
                            const logEntry = {
                                date: formData.date,
                                paymentAmount: paymentAmount,
                                interestAccrued: interestAccrued,
                                principalPaid: principalPaid,
                                balanceBefore: debt.currentBalance,
                                balanceAfter: newBalance,
                                daysSinceLastPayment: daysSinceLastPayment
                            };
                            
                            const updatedDebts = [...debts];
                            updatedDebts[debtIndex] = {
                                ...debt,
                                currentBalance: newBalance,
                                lastUpdated: formData.date,
                                transactionLog: [...transactionLog, logEntry]
                            };
                            setDebts(updatedDebts);
                        }
                    }
                    
                    setFormData({ type: 'expense', amount: '', description: '', category: '', date: getLocalDateString(), linkedDebt: '' });
                    setShowCustomCategory(false);
                    setCustomCategory('');
                }
            };

            const addBulkRow = () => {
                setBulkRows([...bulkRows, { 
                    id: Date.now(), 
                    date: getLocalDateString(), 
                    description: '', 
                    amount: '', 
                    category: '', 
                    type: 'expense' 
                }]);
            };

            const removeBulkRow = (id) => {
                if (bulkRows.length > 1) {
                    setBulkRows(bulkRows.filter(row => row.id !== id));
                }
            };

            const updateBulkRow = (id, field, value) => {
                setBulkRows(bulkRows.map(row => 
                    row.id === id ? { ...row, [field]: value } : row
                ));
            };

            const handleBulkSubmit = (e) => {
                e.preventDefault();
                const validRows = bulkRows.filter(row => row.description && row.amount && row.category);
                
                if (validRows.length === 0) {
                    alert('Please fill out at least one complete transaction (description, amount, and category).');
                    return;
                }

                const newTransactions = validRows.map(row => ({
                    type: row.type,
                    amount: parseFloat(row.amount),
                    description: row.description,
                    category: row.category,
                    date: row.date,
                    id: Date.now() + Math.random()
                }));

                setTransactions([...transactions, ...newTransactions]);
                
                // Reset bulk rows
                setBulkRows([
                    { id: Date.now() + 1, date: getLocalDateString(), description: '', amount: '', category: '', type: 'expense' },
                    { id: Date.now() + 2, date: getLocalDateString(), description: '', amount: '', category: '', type: 'expense' },
                    { id: Date.now() + 3, date: getLocalDateString(), description: '', amount: '', category: '', type: 'expense' }
                ]);
                
                alert(`Successfully added ${newTransactions.length} transaction${newTransactions.length !== 1 ? 's' : ''}!`);
            };

            const handleEdit = (transaction) => {
                setEditingTransaction(transaction);
            };

            const handleUpdate = (updatedTransaction) => {
                setTransactions(transactions.map(t => t.id === updatedTransaction.id ? updatedTransaction : t));
                setEditingTransaction(null);
            };

            const deleteTransaction = (id) => setTransactions(transactions.filter(t => t.id !== id));
            const toggleMonth = (monthKey) => setExpandedMonths(prev => ({ ...prev, [monthKey]: !prev[monthKey] }));
            const getAllCategories = () => { const categories = new Set(); transactions.forEach(t => { if (t.category) categories.add(t.category); }); return ['All', ...Array.from(categories).sort()]; };
            const filterTransactionsByCategory = (transactionsList) => selectedCategory === 'All' ? transactionsList : transactionsList.filter(t => t.category === selectedCategory);
            const groupTransactionsByMonth = () => {
                const grouped = {};
                const filteredTransactions = filterTransactionsByCategory(transactions);
                filteredTransactions.forEach(transaction => {
                    const date = parseLocalDate(transaction.date);
                    const day = date.getDate();
                    let financialMonth, financialYear;
                    if (day >= 28) { financialMonth = date.getMonth() + 1; financialYear = date.getFullYear(); if (financialMonth > 11) { financialMonth = 0; financialYear++; } } else { financialMonth = date.getMonth(); financialYear = date.getFullYear(); }
                    const monthKey = `${financialYear}-${String(financialMonth + 1).padStart(2, '0')}`;
                    const monthLabel = new Date(financialYear, financialMonth, 1).toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                    if (!grouped[monthKey]) { grouped[monthKey] = { label: monthLabel, transactions: [], income: 0, expenses: 0 }; }
                    grouped[monthKey].transactions.push(transaction);
                    const amount = parseFloat(transaction.amount) || 0;
                    if (transaction.type === 'income') { grouped[monthKey].income += amount; } else { grouped[monthKey].expenses += amount; }
                });
                return Object.entries(grouped).sort((a, b) => b[0].localeCompare(a[0]));
            };

            const categories = getAllCategories();
            
            // Normalize string for smart matching (remove spaces, punctuation, lowercase)
            const normalizeForSearch = (str) => {
                return str.toLowerCase().replace(/[\s\-_.]/g, '');
            };
            
            // Filter transactions by search place with smart matching
            const filterByPlace = (transactionsList) => {
                if (!searchPlace.trim()) return transactionsList;
                const normalizedSearch = normalizeForSearch(searchPlace);
                return transactionsList.filter(t => 
                    normalizeForSearch(t.description).includes(normalizedSearch)
                );
            };
            
            const filteredByCategory = filterTransactionsByCategory(transactions);
            const filteredByPlace = filterByPlace(filteredByCategory);
            
            // Calculate totals for search results
            const searchTotals = searchPlace.trim() ? {
                thisMonth: filteredByPlace.filter(t => {
                    const tDate = parseLocalDate(t.date);
                    const { start, end } = getFinancialMonthRange(currentMonth);
                    return tDate >= start && tDate <= end;
                }).reduce((sum, t) => sum + parseFloat(t.amount), 0),
                allTime: filteredByPlace.reduce((sum, t) => sum + parseFloat(t.amount), 0)
            } : null;
            
            const groupTransactionsByMonthFiltered = () => {
                const grouped = {};
                filteredByPlace.forEach(transaction => {
                    const date = parseLocalDate(transaction.date);
                    const day = date.getDate();
                    let financialMonth, financialYear;
                    if (day >= 28) { financialMonth = date.getMonth() + 1; financialYear = date.getFullYear(); if (financialMonth > 11) { financialMonth = 0; financialYear++; } } else { financialMonth = date.getMonth(); financialYear = date.getFullYear(); }
                    const monthKey = `${financialYear}-${String(financialMonth + 1).padStart(2, '0')}`;
                    const monthLabel = new Date(financialYear, financialMonth, 1).toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                    if (!grouped[monthKey]) { grouped[monthKey] = { label: monthLabel, transactions: [], income: 0, expenses: 0 }; }
                    grouped[monthKey].transactions.push(transaction);
                    const amount = parseFloat(transaction.amount) || 0;
                    if (transaction.type === 'income') { grouped[monthKey].income += amount; } else { grouped[monthKey].expenses += amount; }
                });
                return Object.entries(grouped).sort((a, b) => b[0].localeCompare(a[0]));
            };
            
            const monthlyGroups = groupTransactionsByMonthFiltered();

            return (
                <div>
                    <div className="section">
                        <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '20px'}}>
                            <h2>{showBulkEntry ? 'Add Multiple Transactions' : 'Add New Transaction'}</h2>
                            <button 
                                type="button"
                                onClick={() => setShowBulkEntry(!showBulkEntry)}
                                style={{background: showBulkEntry ? '#6c757d' : 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'}}
                            >
                                {showBulkEntry ? '‚Üê Single Entry' : 'üìù Bulk Entry'}
                            </button>
                        </div>
                        
                        {showBulkEntry ? (
                            <form onSubmit={handleBulkSubmit}>
                                <div style={{overflowX: 'auto'}}>
                                    <table style={{width: '100%', borderCollapse: 'collapse', marginBottom: '20px'}}>
                                        <thead>
                                            <tr style={{background: '#1a1f2e'}}>
                                                <th style={{padding: '12px', textAlign: 'left', color: '#667eea', border: '1px solid #2d3748'}}>Type</th>
                                                <th style={{padding: '12px', textAlign: 'left', color: '#667eea', border: '1px solid #2d3748'}}>Date</th>
                                                <th style={{padding: '12px', textAlign: 'left', color: '#667eea', border: '1px solid #2d3748'}}>Description</th>
                                                <th style={{padding: '12px', textAlign: 'left', color: '#667eea', border: '1px solid #2d3748'}}>Amount</th>
                                                <th style={{padding: '12px', textAlign: 'left', color: '#667eea', border: '1px solid #2d3748'}}>Category</th>
                                                <th style={{padding: '12px', textAlign: 'center', color: '#667eea', border: '1px solid #2d3748', width: '80px'}}>Action</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {bulkRows.map(row => (
                                                <tr key={row.id} style={{background: '#0f1419'}}>
                                                    <td style={{padding: '8px', border: '1px solid #2d3748'}}>
                                                        <select 
                                                            value={row.type} 
                                                            onChange={(e) => updateBulkRow(row.id, 'type', e.target.value)}
                                                            style={{width: '100%', padding: '8px'}}
                                                        >
                                                            <option value="expense">Expense</option>
                                                            <option value="income">Income</option>
                                                        </select>
                                                    </td>
                                                    <td style={{padding: '8px', border: '1px solid #2d3748'}}>
                                                        <input 
                                                            type="date" 
                                                            value={row.date} 
                                                            onChange={(e) => updateBulkRow(row.id, 'date', e.target.value)}
                                                            style={{width: '100%', padding: '8px'}}
                                                        />
                                                    </td>
                                                    <td style={{padding: '8px', border: '1px solid #2d3748'}}>
                                                        <input 
                                                            type="text" 
                                                            value={row.description} 
                                                            onChange={(e) => updateBulkRow(row.id, 'description', e.target.value)}
                                                            placeholder="e.g., 7 Brew"
                                                            style={{width: '100%', padding: '8px'}}
                                                        />
                                                    </td>
                                                    <td style={{padding: '8px', border: '1px solid #2d3748'}}>
                                                        <input 
                                                            type="number" 
                                                            step="0.01" 
                                                            value={row.amount} 
                                                            onChange={(e) => updateBulkRow(row.id, 'amount', e.target.value)}
                                                            placeholder="0.00"
                                                            style={{width: '100%', padding: '8px'}}
                                                        />
                                                    </td>
                                                    <td style={{padding: '8px', border: '1px solid #2d3748'}}>
                                                        <select 
                                                            value={row.category} 
                                                            onChange={(e) => updateBulkRow(row.id, 'category', e.target.value)}
                                                            style={{width: '100%', padding: '8px'}}
                                                        >
                                                            <option value="">Select...</option>
                                                            {(row.type === 'expense' ? expenseCategories : incomeCategories).map(cat => 
                                                                <option key={cat} value={cat}>{cat}</option>
                                                            )}
                                                        </select>
                                                    </td>
                                                    <td style={{padding: '8px', border: '1px solid #2d3748', textAlign: 'center'}}>
                                                        <button 
                                                            type="button" 
                                                            onClick={() => removeBulkRow(row.id)}
                                                            className="danger"
                                                            style={{padding: '6px 12px', fontSize: '0.9em'}}
                                                            disabled={bulkRows.length === 1}
                                                        >
                                                            ‚úï
                                                        </button>
                                                    </td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                </div>
                                <div style={{display: 'flex', gap: '10px', marginTop: '15px'}}>
                                    <button type="button" onClick={addBulkRow} className="secondary">+ Add Row</button>
                                    <button type="submit">üíæ Save All ({bulkRows.filter(r => r.description && r.amount && r.category).length} ready)</button>
                                </div>
                            </form>
                        ) : (
                            <form onSubmit={handleSubmit}>
                            <div className="form-row">
                                <div className="form-group"><label>Type</label><select value={formData.type} onChange={(e) => setFormData({...formData, type: e.target.value})}><option value="income">Income</option><option value="expense">Expense</option></select></div>
                                <div className="form-group"><label>Amount</label><input type="number" step="0.01" value={formData.amount} onChange={(e) => setFormData({...formData, amount: e.target.value})} placeholder="0.00" required /></div>
                                <div className="form-group"><label>Date</label><input type="date" value={formData.date} onChange={(e) => setFormData({...formData, date: e.target.value})} required /></div>
                            </div>
                            <div className="form-row">
                                <div className="form-group"><label>Description</label><input type="text" value={formData.description} onChange={(e) => setFormData({...formData, description: e.target.value})} placeholder="e.g., Grocery shopping" required /></div>
                                <div className="form-group">
                                    <label>Category</label>
                                    <select 
                                        value={showCustomCategory ? 'custom' : formData.category} 
                                        onChange={(e) => {
                                            if (e.target.value === 'custom') {
                                                setShowCustomCategory(true);
                                                setFormData({...formData, category: ''});
                                            } else {
                                                setShowCustomCategory(false);
                                                setCustomCategory('');
                                                setFormData({...formData, category: e.target.value});
                                            }
                                        }} 
                                        required={!showCustomCategory}
                                    >
                                        <option value="">Select category</option>
                                        {(formData.type === 'expense' ? expenseCategories : incomeCategories).map(cat => 
                                            <option key={cat} value={cat}>{cat}</option>
                                        )}
                                        <option value="custom">+ Custom Category</option>
                                    </select>
                                </div>
                                {showCustomCategory && (
                                    <div className="form-group">
                                        <label>Custom Category</label>
                                        <input 
                                            type="text" 
                                            value={customCategory} 
                                            onChange={(e) => setCustomCategory(e.target.value)} 
                                            placeholder="Enter category name" 
                                            required 
                                        />
                                    </div>
                                )}
                            </div>
                            {formData.type === 'expense' && debts.length > 0 && (
                                <div className="form-row">
                                    <div className="form-group">
                                        <label>üí≥ Apply to Debt (Optional)</label>
                                        <select 
                                            value={formData.linkedDebt} 
                                            onChange={(e) => setFormData({...formData, linkedDebt: e.target.value})}
                                        >
                                            <option value="">None - Regular expense</option>
                                            {debts.map(debt => (
                                                <option key={debt.id} value={debt.id}>
                                                    {debt.name} (Balance: {formatCurrency(debt.currentBalance)})
                                                </option>
                                            ))}
                                        </select>
                                        <p style={{color: '#a0aec0', fontSize: '0.85em', marginTop: '5px'}}>
                                            Select a debt to apply this payment toward principal reduction
                                        </p>
                                    </div>
                                </div>
                            )}
                            <button type="submit">Add Transaction</button>
                        </form>
                        )}
                    </div>
                    <div className="section">
                        <h2>Transaction History</h2>
                        <div style={{marginBottom: '20px'}}>
                            <label>üîç Search by Place/Description</label>
                            <input 
                                type="text" 
                                value={searchPlace} 
                                onChange={(e) => setSearchPlace(e.target.value)}
                                placeholder="e.g., 7 Brew, Kroger, Amazon..." 
                                style={{marginTop: '8px'}}
                            />
                            {searchTotals && (
                                <div style={{marginTop: '10px', padding: '15px', background: '#1a1f2e', borderRadius: '8px', border: '2px solid #667eea'}}>
                                    <p style={{color: '#e2e8f0', marginBottom: '5px'}}>
                                        <strong style={{color: '#667eea'}}>"{searchPlace}"</strong> - Found {filteredByPlace.length} transaction{filteredByPlace.length !== 1 ? 's' : ''}
                                    </p>
                                    <p style={{color: '#a0aec0', fontSize: '0.95em'}}>
                                        This Month: <strong style={{color: '#667eea'}}>{formatCurrency(searchTotals.thisMonth)}</strong> ‚Ä¢ 
                                        All Time: <strong style={{color: '#667eea'}}>{formatCurrency(searchTotals.allTime)}</strong>
                                    </p>
                                </div>
                            )}
                        </div>
                        <div className="category-filters">
                            {categories.map(category => (
                                <button key={category} className={`category-filter-btn ${selectedCategory === category ? 'active' : ''}`} onClick={() => setSelectedCategory(category)}>{category}</button>
                            ))}
                        </div>
                        {monthlyGroups.length === 0 ? (
                            <p style={{color: '#a0aec0', textAlign: 'center', padding: '20px'}}>No transactions {selectedCategory !== 'All' ? `in category "${selectedCategory}"` : 'yet'}.</p>
                        ) : (
                            monthlyGroups.map(([monthKey, data]) => (
                                <div key={monthKey} className="collapsible-section">
                                    <div className="collapsible-header" onClick={() => toggleMonth(monthKey)}>
                                        <div><h3>{data.label}</h3><p style={{fontSize: '0.9em', marginTop: '5px', opacity: 0.9}}>{data.transactions.length} transaction{data.transactions.length !== 1 ? 's' : ''} ‚Ä¢ Income: {formatCurrency(data.income)} ‚Ä¢ Expenses: {formatCurrency(data.expenses)}</p></div>
                                        <div style={{fontSize: '1.5em'}}>{expandedMonths[monthKey] ? '‚ñº' : '‚ñ∂'}</div>
                                    </div>
                                    {expandedMonths[monthKey] && (
                                        <div className="collapsible-content">
                                            <div className="transaction-list">
                                                {[...data.transactions].sort((a, b) => new Date(b.date) - new Date(a.date)).map((transaction) => (
                                                    <div key={transaction.id} className={`transaction-item ${transaction.type}`}>
                                                        <div className="item-details"><h4>{transaction.description}</h4><p>{transaction.category} ‚Ä¢ {transaction.date}</p></div>
                                                        <div style={{display: 'flex', alignItems: 'center', gap: '15px'}}>
                                                            <div className={`item-amount ${transaction.type === 'income' ? 'positive' : 'negative'}`}>{transaction.type === 'income' ? '+' : '-'}{formatCurrency(Math.abs(parseFloat(transaction.amount) || 0))}</div>
                                                            <button onClick={() => handleEdit(transaction)} style={{padding: '8px 16px', fontSize: '0.9em'}}>Edit</button>
                                                            <button className="danger" onClick={() => deleteTransaction(transaction.id)} style={{padding: '8px 16px', fontSize: '0.9em'}}>Delete</button>
                                                        </div>
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            ))
                        )}
                    </div>
                    {editingTransaction && <EditTransactionModal transaction={editingTransaction} onUpdate={handleUpdate} onClose={() => setEditingTransaction(null)} />}
                </div>
            );
        }

        function EditTransactionModal({ transaction, onUpdate, onClose }) {
            const [formData, setFormData] = useState({ ...transaction });

            const handleSubmit = (e) => {
                e.preventDefault();
                onUpdate({ ...formData, amount: parseFloat(formData.amount) });
            };

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="modal" onClick={(e) => e.stopPropagation()}>
                        <h2>Edit Transaction</h2>
                        <form onSubmit={handleSubmit}>
                            <div className="form-row">
                                <div className="form-group"><label>Type</label><select value={formData.type} onChange={(e) => setFormData({...formData, type: e.target.value})}><option value="income">Income</option><option value="expense">Expense</option></select></div>
                                <div className="form-group"><label>Amount</label><input type="number" step="0.01" value={formData.amount} onChange={(e) => setFormData({...formData, amount: e.target.value})} required /></div>
                                <div className="form-group"><label>Date</label><input type="date" value={formData.date} onChange={(e) => setFormData({...formData, date: e.target.value})} required /></div>
                            </div>
                            <div className="form-row">
                                <div className="form-group"><label>Description</label><input type="text" value={formData.description} onChange={(e) => setFormData({...formData, description: e.target.value})} required /></div>
                                <div className="form-group"><label>Category</label><input type="text" value={formData.category} onChange={(e) => setFormData({...formData, category: e.target.value})} /></div>
                            </div>
                            <div style={{display: 'flex', gap: '10px', marginTop: '20px'}}>
                                <button type="submit">Save Changes</button>
                                <button type="button" className="secondary" onClick={onClose}>Cancel</button>
                            </div>
                        </form>
                    </div>
                </div>
            );
        }

        function RecurringTab({ recurringPayments, setRecurringPayments, debts, setDebts, transactions, setTransactions, paidPayments, setPaidPayments, currentMonth }) {
            const [formData, setFormData] = useState({ name: '', amount: '', category: '', dueDay: '1', linkedDebt: '', auto: false });
            const [editingPayment, setEditingPayment] = useState(null);
            const monthKey = getMonthKey(currentMonth);

            // Check if auto-pay should be marked as paid (due date has passed in financial month)
            const shouldAutoPayBePaid = (payment) => {
                if (!payment.auto) return false;
                const today = new Date();
                const currentDay = today.getDate();
                const { start } = getFinancialMonthRange(currentMonth);
                
                // Create a date for the payment due day in the financial month
                let paymentDate;
                if (payment.dueDay >= 28) {
                    // Days 28-31 are at the START of the financial month (previous calendar month)
                    paymentDate = new Date(start.getFullYear(), start.getMonth(), payment.dueDay);
                } else {
                    // Days 1-27 are in the NEXT calendar month after start
                    paymentDate = new Date(start.getFullYear(), start.getMonth() + 1, payment.dueDay);
                }
                
                // Payment is paid if today >= payment date
                return today >= paymentDate;
            };

            const handleSubmit = (e) => { 
                e.preventDefault(); 
                if (formData.name && formData.amount) { 
                    const newPayment = { ...formData, amount: parseFloat(formData.amount), dueDay: parseInt(formData.dueDay), id: Date.now() };
                    setRecurringPayments([...recurringPayments, newPayment]); 
                    
                    // Auto-pay: mark as paid if due date has already passed this month
                    if (formData.auto && shouldAutoPayBePaid(newPayment)) {
                        const paymentKey = `${monthKey}-${newPayment.id}`;
                        setPaidPayments({...paidPayments, [paymentKey]: true});
                    }
                    
                    setFormData({ name: '', amount: '', category: '', dueDay: '1', linkedDebt: '', auto: false }); 
                } 
            };

            const deletePayment = (id) => setRecurringPayments(recurringPayments.filter(p => p.id !== id));
            
            const handleEdit = (payment) => {
                setEditingPayment(payment);
            };

            const handleUpdate = (updatedPayment) => {
                setRecurringPayments(recurringPayments.map(p => p.id === updatedPayment.id ? updatedPayment : p));
                setEditingPayment(null);
            };
            
            const processPayment = (payment) => {
                console.log('Processing payment:', payment.name);
                console.log('Linked debt ID:', payment.linkedDebt);
                
                const paymentKey = `${monthKey}-${payment.id}`;
                const newTransaction = { type: 'expense', amount: payment.amount, description: `${payment.name} (Recurring)`, category: payment.category, date: getLocalDateString(), id: Date.now() };
                setTransactions([...transactions, newTransaction]);
                setPaidPayments({...paidPayments, [paymentKey]: true});
                
                if (payment.linkedDebt) {
                    console.log('Payment has linked debt, processing...');
                    setDebts(debts.map(debt => { 
                        if (debt.id === parseInt(payment.linkedDebt)) {
                            console.log('Found matching debt:', debt.name);
                            const interestRate = parseFloat(debt.interestRate) || 0;
                            const monthlyInterestRate = interestRate / 100 / 12;
                            const interestAccrued = debt.currentBalance * monthlyInterestRate;
                            const principalPaid = payment.amount - interestAccrued;
                            const newBalance = Math.max(0, debt.currentBalance - principalPaid);
                            
                            const transactionLog = debt.transactionLog || [];
                            const logEntry = {
                                date: getLocalDateString(),
                                paymentAmount: payment.amount,
                                interestAccrued: interestAccrued,
                                principalPaid: principalPaid,
                                balanceBefore: debt.currentBalance,
                                balanceAfter: newBalance
                            };
                            
                            console.log('Creating log entry:', logEntry);
                            console.log('Transaction log length before:', transactionLog.length);
                            console.log('Transaction log length after:', transactionLog.length + 1);
                            
                            return { 
                                ...debt, 
                                currentBalance: newBalance,
                                transactionLog: [...transactionLog, logEntry]
                            }; 
                        } 
                        return debt; 
                    })); 
                }
                alert(`Payment processed: ${payment.name} for ${formatCurrency(payment.amount)}`);
            };

            const togglePaidStatus = (paymentId) => {
                const paymentKey = `${monthKey}-${paymentId}`;
                setPaidPayments(prevPaid => ({
                    ...prevPaid, 
                    [paymentKey]: !prevPaid[paymentKey]
                }));
            };

            return (
                <div>
                    <div className="section">
                        <h2>Add Recurring Payment</h2>
                        <form onSubmit={handleSubmit}>
                            <div className="form-row">
                                <div className="form-group"><label>Payment Name</label><input type="text" value={formData.name} onChange={(e) => setFormData({...formData, name: e.target.value})} placeholder="e.g., Mortgage, Netflix" required /></div>
                                <div className="form-group"><label>Amount</label><input type="number" step="0.01" value={formData.amount} onChange={(e) => setFormData({...formData, amount: e.target.value})} placeholder="0.00" required /></div>
                            </div>
                            <div className="form-row">
                                <div className="form-group"><label>Category</label><input type="text" value={formData.category} onChange={(e) => setFormData({...formData, category: e.target.value})} placeholder="e.g., Housing, Entertainment" /></div>
                                <div className="form-group"><label>Due Day (1-31)</label><input type="number" min="1" max="31" value={formData.dueDay} onChange={(e) => setFormData({...formData, dueDay: e.target.value})} required /></div>
                                <div className="form-group"><label>Link to Debt (Optional)</label><select value={formData.linkedDebt} onChange={(e) => setFormData({...formData, linkedDebt: e.target.value})}><option value="">None</option>{debts.map(debt => (<option key={debt.id} value={debt.id}>{debt.name}</option>))}</select></div>
                            </div>
                            <div className="form-group" style={{marginBottom: '0'}}>
                                <label style={{display: 'flex', alignItems: 'center', cursor: 'pointer'}}>
                                    <input type="checkbox" checked={formData.auto} onChange={(e) => setFormData({...formData, auto: e.target.checked})} style={{width: 'auto', marginRight: '10px'}} />
                                    Auto-pay (mark as paid when due date passes)
                                </label>
                            </div>
                            <button type="submit" style={{marginTop: '20px'}}>Add Recurring Payment</button>
                        </form>
                    </div>
                    <div className="section">
                        <h2>Recurring Payments ({recurringPayments.length})</h2>
                        <p style={{color: '#a0aec0', marginBottom: '15px', fontSize: '1.1em'}}>
                            Total Monthly: <strong style={{color: '#667eea'}}>{formatCurrency(recurringPayments.reduce((sum, p) => sum + parseFloat(p.amount), 0))}</strong>
                        </p>
                        <div className="payment-list">
                            {recurringPayments.length === 0 ? (
                                <p style={{color: '#a0aec0', textAlign: 'center', padding: '20px'}}>No recurring payments yet.</p>
                            ) : (
                                recurringPayments.sort((a, b) => a.dueDay - b.dueDay).map((payment) => {
                                    const linkedDebt = payment.linkedDebt ? debts.find(d => d.id === parseInt(payment.linkedDebt)) : null;
                                    const isManuallyPaid = paidPayments[`${monthKey}-${payment.id}`];
                                    const isAutoPaid = payment.auto && shouldAutoPayBePaid(payment);
                                    const isPaid = isManuallyPaid || isAutoPaid;
                                    
                                    return (
                                        <div key={payment.id} className={`payment-item ${isPaid ? 'paid' : 'unpaid'}`}>
                                            <div className="item-details">
                                                <h4>
                                                    {payment.name}
                                                    {isPaid && <span className="paid-badge">‚úì Paid</span>}
                                                    {payment.auto ? <span className="auto-badge">AUTO</span> : <span className="manual-badge">MANUAL</span>}
                                                </h4>
                                                <p>{payment.category} ‚Ä¢ Due: Day {payment.dueDay}{linkedDebt && ` ‚Ä¢ Linked to: ${linkedDebt.name}`}</p>
                                            </div>
                                            <div style={{display: 'flex', alignItems: 'center', gap: '15px'}}>
                                                <div className="item-amount negative">{formatCurrency(payment.amount)}</div>
                                                {!isPaid && !payment.auto && <button onClick={() => processPayment(payment)} style={{padding: '8px 16px', fontSize: '0.9em'}}>Process</button>}
                                                {!payment.auto && <button className={isPaid ? 'secondary' : 'success'} onClick={() => togglePaidStatus(payment.id)} style={{padding: '8px 16px', fontSize: '0.9em'}}>{isPaid ? 'Mark Unpaid' : 'Mark Paid'}</button>}
                                                <button onClick={() => handleEdit(payment)} style={{padding: '8px 16px', fontSize: '0.9em'}}>Edit</button>
                                                <button className="danger" onClick={() => deletePayment(payment.id)} style={{padding: '8px 16px', fontSize: '0.9em'}}>Delete</button>
                                            </div>
                                        </div>
                                    );
                                })
                            )}
                        </div>
                    </div>
                    {editingPayment && <EditRecurringPaymentModal payment={editingPayment} onUpdate={handleUpdate} onClose={() => setEditingPayment(null)} debts={debts} />}
                </div>
            );
        }

        function EditRecurringPaymentModal({ payment, onUpdate, onClose, debts }) {
            const [formData, setFormData] = useState({ ...payment });

            const handleSubmit = (e) => {
                e.preventDefault();
                onUpdate({ ...formData, amount: parseFloat(formData.amount), dueDay: parseInt(formData.dueDay) });
            };

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="modal" onClick={(e) => e.stopPropagation()}>
                        <h2>Edit Recurring Payment</h2>
                        <form onSubmit={handleSubmit}>
                            <div className="form-row">
                                <div className="form-group"><label>Payment Name</label><input type="text" value={formData.name} onChange={(e) => setFormData({...formData, name: e.target.value})} required /></div>
                                <div className="form-group"><label>Amount</label><input type="number" step="0.01" value={formData.amount} onChange={(e) => setFormData({...formData, amount: e.target.value})} required /></div>
                            </div>
                            <div className="form-row">
                                <div className="form-group"><label>Category</label><input type="text" value={formData.category} onChange={(e) => setFormData({...formData, category: e.target.value})} /></div>
                                <div className="form-group"><label>Due Day (1-31)</label><input type="number" min="1" max="31" value={formData.dueDay} onChange={(e) => setFormData({...formData, dueDay: e.target.value})} required /></div>
                                <div className="form-group"><label>Link to Debt</label><select value={formData.linkedDebt || ''} onChange={(e) => setFormData({...formData, linkedDebt: e.target.value})}><option value="">None</option>{debts.map(debt => (<option key={debt.id} value={debt.id}>{debt.name}</option>))}</select></div>
                            </div>
                            <div className="form-group" style={{marginBottom: '0'}}>
                                <label style={{display: 'flex', alignItems: 'center', cursor: 'pointer'}}>
                                    <input type="checkbox" checked={formData.auto || false} onChange={(e) => setFormData({...formData, auto: e.target.checked})} style={{width: 'auto', marginRight: '10px'}} />
                                    Auto-pay
                                </label>
                            </div>
                            <div style={{display: 'flex', gap: '10px', marginTop: '20px'}}>
                                <button type="submit">Save Changes</button>
                                <button type="button" className="secondary" onClick={onClose}>Cancel</button>
                            </div>
                        </form>
                    </div>
                </div>
            );
        }

        function DebtsTab({ debts, setDebts }) {
            const [formData, setFormData] = useState({ name: '', originalBalance: '', currentBalance: '', interestRate: '', minimumPayment: '', category: 'Credit Card' });
            const [expandedDebt, setExpandedDebt] = useState(null);
            const [editingDebt, setEditingDebt] = useState(null);
            
            const handleSubmit = (e) => { e.preventDefault(); if (formData.name && formData.currentBalance) { setDebts([...debts, { ...formData, originalBalance: parseFloat(formData.originalBalance) || parseFloat(formData.currentBalance), currentBalance: parseFloat(formData.currentBalance), interestRate: parseFloat(formData.interestRate) || 0, minimumPayment: parseFloat(formData.minimumPayment) || 0, id: Date.now() }]); setFormData({ name: '', originalBalance: '', currentBalance: '', interestRate: '', minimumPayment: '', category: 'Credit Card' }); } };
            const deleteDebt = (id) => setDebts(debts.filter(d => d.id !== id));
            
            const handleEdit = (debt) => {
                setEditingDebt(debt);
            };
            
            const handleUpdate = (updatedDebt) => {
                setDebts(debts.map(d => d.id === updatedDebt.id ? updatedDebt : d));
                setEditingDebt(null);
            };
            
            const calculatePayoffMonths = (debt) => { if (debt.minimumPayment <= 0 || debt.currentBalance <= 0) return 'N/A'; const monthlyRate = (debt.interestRate / 100) / 12; let balance = debt.currentBalance; let months = 0; while (balance > 0 && months < 600) { const interest = balance * monthlyRate; const principal = debt.minimumPayment - interest; if (principal <= 0) return '‚àû (payment < interest)'; balance -= principal; months++; } return months; };
            const formatPayoffDate = (months) => { if (months === 'N/A' || typeof months === 'string') return months; const today = new Date(); const payoffDate = new Date(today.getFullYear(), today.getMonth() + months, today.getDate()); return payoffDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' }); };

            return (
                <div>
                    {debts.length > 0 && (
                        <div className="section" style={{background: 'linear-gradient(135deg, #dc354522 0%, #c92a2a22 100%)', border: '2px solid #dc3545'}}>
                            <h2 style={{color: '#dc3545', marginBottom: '20px'}}>üí∏ Debt Overview</h2>
                            <div className="debt-overview-grid">
                                {debts.map(debt => {
                                    const originalBalance = parseFloat(debt.originalBalance) || 0;
                                    const currentBalance = parseFloat(debt.currentBalance) || 0;
                                    const interestRate = parseFloat(debt.interestRate) || 0;
                                    const progressPercent = originalBalance > 0 ? ((originalBalance - currentBalance) / originalBalance * 100) : 0;
                                    return (
                                        <div key={debt.id} className="debt-mini-card">
                                            <h4>{debt.name}</h4>
                                            <div className="debt-amount">{formatCurrency(currentBalance)}</div>
                                            <div className="debt-info">{debt.category}</div>
                                            <div className="debt-info">{interestRate.toFixed(2)}% APR</div>
                                            <div className="progress-bar" style={{marginTop: '8px'}}><div className="progress-fill" style={{width: `${Math.min(progressPercent, 100)}%`}}></div></div>
                                            <div className="debt-info" style={{marginTop: '5px'}}>{progressPercent.toFixed(1)}% paid off</div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    )}
                    <div className="section">
                        <h2>Add New Debt</h2>
                        <form onSubmit={handleSubmit}>
                            <div className="form-row">
                                <div className="form-group"><label>Debt Name</label><input type="text" value={formData.name} onChange={(e) => setFormData({...formData, name: e.target.value})} placeholder="e.g., Visa Card, Car Loan" required /></div>
                                <div className="form-group"><label>Category</label><select value={formData.category} onChange={(e) => setFormData({...formData, category: e.target.value})}><option value="Credit Card">Credit Card</option><option value="Auto Loan">Auto Loan</option><option value="Mortgage">Mortgage</option><option value="Personal Loan">Personal Loan</option><option value="Student Loan">Student Loan</option><option value="Other">Other</option></select></div>
                            </div>
                            <div className="form-row">
                                <div className="form-group"><label>Original Balance</label><input type="number" step="0.01" value={formData.originalBalance} onChange={(e) => setFormData({...formData, originalBalance: e.target.value})} placeholder="0.00" /></div>
                                <div className="form-group"><label>Current Balance</label><input type="number" step="0.01" value={formData.currentBalance} onChange={(e) => setFormData({...formData, currentBalance: e.target.value})} placeholder="0.00" required /></div>
                                <div className="form-group"><label>Interest Rate (%)</label><input type="number" step="0.01" value={formData.interestRate} onChange={(e) => setFormData({...formData, interestRate: e.target.value})} placeholder="0.00" /></div>
                                <div className="form-group"><label>Minimum Payment</label><input type="number" step="0.01" value={formData.minimumPayment} onChange={(e) => setFormData({...formData, minimumPayment: e.target.value})} placeholder="0.00" /></div>
                            </div>
                            <button type="submit">Add Debt</button>
                        </form>
                    </div>
                    <div className="section">
                        <h2>Active Debts ({debts.length})</h2>
                        <p style={{color: '#a0aec0', marginBottom: '15px', fontSize: '1.1em'}}>
                            Total Debt: <strong style={{color: '#dc3545'}}>{formatCurrency(debts.reduce((sum, d) => sum + parseFloat(d.currentBalance), 0))}</strong>
                        </p>
                        <div className="debt-list">
                            {debts.length === 0 ? (
                                <p style={{color: '#a0aec0', textAlign: 'center', padding: '20px'}}>No debts tracked yet.</p>
                            ) : (
                                debts.map((debt) => {
                                    const payoffMonths = calculatePayoffMonths(debt);
                                    const payoffDate = formatPayoffDate(payoffMonths);
                                    const progressPercent = debt.originalBalance > 0 ? ((debt.originalBalance - debt.currentBalance) / debt.originalBalance * 100) : 0;
                                    return (
                                        <div key={debt.id} className="collapsible-section">
                                            <div className="collapsible-header" onClick={() => setExpandedDebt(expandedDebt === debt.id ? null : debt.id)}>
                                                <div><h3>{debt.name}</h3><p style={{fontSize: '0.9em', marginTop: '5px', opacity: 0.9}}>{debt.category} ‚Ä¢ Balance: {formatCurrency(debt.currentBalance)}</p></div>
                                                <div style={{fontSize: '1.5em'}}>{expandedDebt === debt.id ? '‚ñº' : '‚ñ∂'}</div>
                                            </div>
                                            {expandedDebt === debt.id && (
                                                <div className="collapsible-content">
                                                    <div className="debt-details">
                                                        <div className="debt-detail-item"><label>Original Balance</label><div className="value">{formatCurrency(debt.originalBalance)}</div></div>
                                                        <div className="debt-detail-item"><label>Current Balance</label><div className="value">{formatCurrency(debt.currentBalance)}</div></div>
                                                        <div className="debt-detail-item"><label>Interest Rate</label><div className="value">{debt.interestRate.toFixed(2)}%</div></div>
                                                        <div className="debt-detail-item"><label>Minimum Payment</label><div className="value">{formatCurrency(debt.minimumPayment)}</div></div>
                                                        <div className="debt-detail-item"><label>Payoff Timeline</label><div className="value">{typeof payoffMonths === 'number' ? `${payoffMonths} months` : payoffMonths}</div></div>
                                                        <div className="debt-detail-item"><label>Projected Payoff</label><div className="value">{payoffDate}</div></div>
                                                    </div>
                                                    <div style={{marginTop: '15px'}}>
                                                        <label style={{display: 'block', marginBottom: '8px', fontSize: '0.9em'}}>Progress: {progressPercent.toFixed(1)}% paid off</label>
                                                        <div className="progress-bar"><div className="progress-fill" style={{width: `${Math.min(progressPercent, 100)}%`}}></div></div>
                                                    </div>
                                                    {debt.transactionLog && debt.transactionLog.length > 0 && (
                                                        <div style={{marginTop: '20px'}}>
                                                            <h4 style={{color: '#667eea', marginBottom: '10px'}}>Transaction History</h4>
                                                            <div style={{maxHeight: '300px', overflowY: 'auto'}}>
                                                                {debt.transactionLog.slice().reverse().map((log, index) => (
                                                                    <div key={index} style={{background: '#1a1f2e', padding: '12px', borderRadius: '8px', marginBottom: '8px', fontSize: '0.9em'}}>
                                                                        <div style={{display: 'flex', justifyContent: 'space-between', marginBottom: '5px'}}>
                                                                            <span style={{color: '#a0aec0'}}>Date:</span>
                                                                            <span style={{color: '#e2e8f0', fontWeight: '600'}}>{new Date(log.date).toLocaleDateString()}</span>
                                                                        </div>
                                                                        <div style={{display: 'flex', justifyContent: 'space-between', marginBottom: '5px'}}>
                                                                            <span style={{color: '#a0aec0'}}>Payment:</span>
                                                                            <span style={{color: '#28a745', fontWeight: '600'}}>{formatCurrency(log.paymentAmount)}</span>
                                                                        </div>
                                                                        <div style={{display: 'flex', justifyContent: 'space-between', marginBottom: '5px'}}>
                                                                            <span style={{color: '#a0aec0'}}>Interest Accrued:</span>
                                                                            <span style={{color: '#dc3545', fontWeight: '600'}}>{formatCurrency(log.interestAccrued)}</span>
                                                                        </div>
                                                                        <div style={{display: 'flex', justifyContent: 'space-between', marginBottom: '5px'}}>
                                                                            <span style={{color: '#a0aec0'}}>Principal Paid:</span>
                                                                            <span style={{color: '#667eea', fontWeight: '600'}}>{formatCurrency(log.principalPaid)}</span>
                                                                        </div>
                                                                        <div style={{display: 'flex', justifyContent: 'space-between', paddingTop: '8px', borderTop: '1px solid #2d3748'}}>
                                                                            <span style={{color: '#a0aec0'}}>Balance:</span>
                                                                            <span style={{color: '#e2e8f0', fontWeight: '600'}}>{formatCurrency(log.balanceBefore)} to {formatCurrency(log.balanceAfter)}</span>
                                                                        </div>
                                                                    </div>
                                                                ))}
                                                            </div>
                                                        </div>
                                                    )}
                                                    <div style={{marginTop: '20px', display: 'flex', gap: '10px'}}>
                                                        <button onClick={() => handleEdit(debt)}>Edit Debt</button>
                                                        <button className="danger" onClick={() => deleteDebt(debt.id)}>Delete Debt</button>
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    );
                                })
                            )}
                        </div>
                    </div>
                    {editingDebt && <EditDebtModal debt={editingDebt} onUpdate={handleUpdate} onClose={() => setEditingDebt(null)} />}
                </div>
            );
        }

        function EditDebtModal({ debt, onUpdate, onClose }) {
            const [formData, setFormData] = useState({ ...debt });

            const handleSubmit = (e) => {
                e.preventDefault();
                onUpdate({ 
                    ...formData, 
                    originalBalance: parseFloat(formData.originalBalance) || 0,
                    currentBalance: parseFloat(formData.currentBalance) || 0,
                    interestRate: parseFloat(formData.interestRate) || 0,
                    minimumPayment: parseFloat(formData.minimumPayment) || 0
                });
            };

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="modal" onClick={(e) => e.stopPropagation()}>
                        <h2>Edit Debt</h2>
                        <form onSubmit={handleSubmit}>
                            <div className="form-row">
                                <div className="form-group">
                                    <label>Debt Name</label>
                                    <input 
                                        type="text" 
                                        value={formData.name} 
                                        onChange={(e) => setFormData({...formData, name: e.target.value})} 
                                        placeholder="e.g., Visa Card, Car Loan" 
                                        required 
                                    />
                                </div>
                                <div className="form-group">
                                    <label>Category</label>
                                    <select 
                                        value={formData.category} 
                                        onChange={(e) => setFormData({...formData, category: e.target.value})}
                                    >
                                        <option value="Credit Card">Credit Card</option>
                                        <option value="Auto Loan">Auto Loan</option>
                                        <option value="Mortgage">Mortgage</option>
                                        <option value="Personal Loan">Personal Loan</option>
                                        <option value="Student Loan">Student Loan</option>
                                        <option value="Other">Other</option>
                                    </select>
                                </div>
                            </div>
                            <div className="form-row">
                                <div className="form-group">
                                    <label>Original Balance</label>
                                    <input 
                                        type="number" 
                                        step="0.01" 
                                        value={formData.originalBalance} 
                                        onChange={(e) => setFormData({...formData, originalBalance: e.target.value})} 
                                        placeholder="0.00" 
                                    />
                                </div>
                                <div className="form-group">
                                    <label>Current Balance</label>
                                    <input 
                                        type="number" 
                                        step="0.01" 
                                        value={formData.currentBalance} 
                                        onChange={(e) => setFormData({...formData, currentBalance: e.target.value})} 
                                        placeholder="0.00" 
                                        required 
                                    />
                                </div>
                                <div className="form-group">
                                    <label>Interest Rate (%)</label>
                                    <input 
                                        type="number" 
                                        step="0.01" 
                                        value={formData.interestRate} 
                                        onChange={(e) => setFormData({...formData, interestRate: e.target.value})} 
                                        placeholder="0.00" 
                                    />
                                </div>
                                <div className="form-group">
                                    <label>Minimum Payment</label>
                                    <input 
                                        type="number" 
                                        step="0.01" 
                                        value={formData.minimumPayment} 
                                        onChange={(e) => setFormData({...formData, minimumPayment: e.target.value})} 
                                        placeholder="0.00" 
                                    />
                                </div>
                            </div>
                            <p style={{color: '#ffc107', fontSize: '0.9em', marginTop: '15px', background: '#0f1419', padding: '10px', borderRadius: '5px'}}>
                                ‚ö†Ô∏è <strong>Note:</strong> Editing current balance will not create a transaction log entry. For payments, use the Transactions or Recurring tabs.
                            </p>
                            <div style={{display: 'flex', gap: '10px', marginTop: '20px'}}>
                                <button type="submit">Save Changes</button>
                                <button type="button" className="secondary" onClick={onClose}>Cancel</button>
                            </div>
                        </form>
                    </div>
                </div>
            );
        }

        function PayoffStrategiesTab({ debts }) {
            const [extraPayment, setExtraPayment] = useState(0);
            const [selectedStrategy, setSelectedStrategy] = useState('snowball');
            const calculatePayoffOrder = (sortedDebts) => {
                const timeline = []; let currentMonth = 0; let totalInterest = 0; let remainingDebts = sortedDebts.map(d => ({ ...d })); const extra = parseFloat(extraPayment) || 0;
                while (remainingDebts.length > 0) {
                    let availableExtra = extra;
                    remainingDebts = remainingDebts.filter(debt => {
                        const monthlyRate = (debt.interestRate / 100) / 12; const interest = debt.currentBalance * monthlyRate; totalInterest += interest;
                        let payment = debt.minimumPayment; if (debt === remainingDebts[0]) { payment += availableExtra; }
                        const principal = payment - interest; debt.currentBalance -= principal;
                        if (debt.currentBalance <= 0) { timeline.push({ name: debt.name, month: currentMonth, category: debt.category }); return false; }
                        return true;
                    });
                    currentMonth++; if (currentMonth > 600) break;
                }
                return { timeline, totalMonths: currentMonth, totalInterest };
            };
            const calculateSnowball = () => { const sortedDebts = [...debts].map(d => ({ ...d, currentBalance: parseFloat(d.currentBalance), minimumPayment: parseFloat(d.minimumPayment), interestRate: parseFloat(d.interestRate) })).sort((a, b) => a.currentBalance - b.currentBalance); return calculatePayoffOrder(sortedDebts); };
            const calculateAvalanche = () => { const sortedDebts = [...debts].map(d => ({ ...d, currentBalance: parseFloat(d.currentBalance), minimumPayment: parseFloat(d.minimumPayment), interestRate: parseFloat(d.interestRate) })).sort((a, b) => b.interestRate - a.interestRate); return calculatePayoffOrder(sortedDebts); };
            const snowballResult = calculateSnowball(); const avalancheResult = calculateAvalanche(); const activeResult = selectedStrategy === 'snowball' ? snowballResult : avalancheResult;
            const formatMonth = (monthNum) => { const date = new Date(); date.setMonth(date.getMonth() + monthNum); return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' }); };

            return (
                <div>
                    <div className="section">
                        <h2>üéØ Debt Payoff Strategies</h2>
                        <p style={{color: '#a0aec0', lineHeight: '1.6', marginBottom: '20px'}}>Compare two popular debt payoff strategies to find the best approach for your situation.</p>
                        <div className="form-row" style={{marginBottom: '20px'}}>
                            <div className="form-group"><label>Extra Monthly Payment</label><input type="number" step="0.01" value={extraPayment} onChange={(e) => setExtraPayment(e.target.value)} placeholder="0.00" /></div>
                            <div className="form-group"><label>View Strategy</label><select value={selectedStrategy} onChange={(e) => setSelectedStrategy(e.target.value)}><option value="snowball">Debt Snowball</option><option value="avalanche">Debt Avalanche</option></select></div>
                        </div>
                    </div>
                    {debts.length === 0 ? (
                        <div className="section"><p style={{color: '#a0aec0', textAlign: 'center', padding: '40px'}}>No debts to analyze. Add debts in the Debt Tracking tab to see payoff strategies.</p></div>
                    ) : (
                        <>
                            <div className="dashboard-grid">
                                <div className="section"><h2>‚ùÑÔ∏è Debt Snowball</h2><p style={{color: '#a0aec0', fontSize: '0.9em', marginBottom: '15px'}}>Pay off smallest balances first for psychological wins</p><div style={{fontSize: '2em', fontWeight: '700', color: '#667eea', marginBottom: '5px'}}>{snowballResult.totalMonths} months</div><div style={{color: '#a0aec0', fontSize: '0.9em'}}>Total Interest: {formatCurrency(snowballResult.totalInterest)}</div><div style={{color: '#a0aec0', fontSize: '0.9em'}}>Debt-Free: {formatMonth(snowballResult.totalMonths)}</div></div>
                                <div className="section"><h2>‚õ∞Ô∏è Debt Avalanche</h2><p style={{color: '#a0aec0', fontSize: '0.9em', marginBottom: '15px'}}>Pay off highest interest rates first to save money</p><div style={{fontSize: '2em', fontWeight: '700', color: '#667eea', marginBottom: '5px'}}>{avalancheResult.totalMonths} months</div><div style={{color: '#a0aec0', fontSize: '0.9em'}}>Total Interest: {formatCurrency(avalancheResult.totalInterest)}</div><div style={{color: '#a0aec0', fontSize: '0.9em'}}>Debt-Free: {formatMonth(avalancheResult.totalMonths)}</div>{avalancheResult.totalInterest < snowballResult.totalInterest && (<div style={{background: '#28a745', color: 'white', padding: '10px', borderRadius: '5px', fontSize: '0.85em', textAlign: 'center', marginTop: '10px'}}>üí∞ Saves {formatCurrency(snowballResult.totalInterest - avalancheResult.totalInterest)} in interest</div>)}</div>
                            </div>
                            <div className="section">
                                <h2>{selectedStrategy === 'snowball' ? '‚ùÑÔ∏è Snowball' : '‚õ∞Ô∏è Avalanche'} Payoff Timeline</h2>
                                <div style={{marginTop: '20px'}}>
                                    {activeResult.timeline.map((item, index) => (
                                        <div key={index} style={{background: '#1a1f2e', padding: '15px 20px', borderRadius: '8px', marginBottom: '10px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', borderLeft: '4px solid #28a745'}}>
                                            <div><h4 style={{color: '#e2e8f0', marginBottom: '5px'}}>{item.name}</h4><p style={{color: '#a0aec0', fontSize: '0.85em'}}>{item.category}</p></div>
                                            <div style={{textAlign: 'right'}}><div style={{color: '#28a745', fontWeight: '700', fontSize: '1.1em'}}>Month {item.month}</div><div style={{color: '#a0aec0', fontSize: '0.85em'}}>{formatMonth(item.month)}</div></div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </>
                    )}
                </div>
            );
        }

        function BudgetTab({ transactions, recurringPayments, expectedMonthlyIncome, setExpectedMonthlyIncome, currentMonth, unpaidRecurring }) {
            const [tempIncome, setTempIncome] = useState(expectedMonthlyIncome);
            const { start, end } = getFinancialMonthRange(currentMonth);
            
            // Get transactions for current month
            const monthTransactions = transactions.filter(t => {
                const tDate = parseLocalDate(t.date);
                return tDate >= start && tDate <= end;
            });

            // Calculate actual income
            const actualIncome = monthTransactions
                .filter(t => t.type === 'income')
                .reduce((sum, t) => sum + parseFloat(t.amount), 0);

            // Calculate total expenses
            const totalExpenses = monthTransactions
                .filter(t => t.type === 'expense')
                .reduce((sum, t) => sum + parseFloat(t.amount), 0);

            // Calculate recurring bills total for this month
            const recurringTotal = recurringPayments
                .filter(p => {
                    let paymentDate;
                    if (p.dueDay >= 28) {
                        paymentDate = new Date(start.getFullYear(), start.getMonth(), p.dueDay);
                    } else {
                        paymentDate = new Date(start.getFullYear(), start.getMonth() + 1, p.dueDay);
                    }
                    return paymentDate >= start && paymentDate <= end;
                })
                .reduce((sum, p) => sum + parseFloat(p.amount), 0);

            // Simple calculations
            const moneyLeft = expectedMonthlyIncome - recurringTotal;
            const spentSoFar = totalExpenses - recurringTotal;
            
            // Calculate with ACTUAL income received so far
            const moneyLeftActual = actualIncome - recurringTotal;
            
            // Remaining = Money Left - Spent So Far - Unpaid Recurring (guaranteed to come out)
            const remainingExpected = moneyLeft - spentSoFar - unpaidRecurring;
            const remainingActual = moneyLeftActual - spentSoFar - unpaidRecurring;

            const handleSaveIncome = () => {
                setExpectedMonthlyIncome(tempIncome);
                alert('Expected monthly income updated!');
            };

            const monthLabel = `${start.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })} - ${end.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}`;

            return (
                <div>
                    <div className="section">
                        <h2>üíµ Income Settings</h2>
                        <div className="income-input-group">
                            <div className="form-group">
                                <label>Expected Monthly Income</label>
                                <input 
                                    type="number" 
                                    value={tempIncome} 
                                    onChange={(e) => setTempIncome(Number(e.target.value))}
                                    placeholder="Enter expected monthly income"
                                />
                            </div>
                            <button onClick={handleSaveIncome}>üíæ Save</button>
                        </div>
                    </div>

                    <div className="budget-overview">
                        <h2 style={{color: '#667eea', marginBottom: '25px', fontSize: '1.8em'}}>üí∞ Money Available This Month</h2>
                        <p style={{color: '#a0aec0', marginBottom: '20px', fontSize: '0.95em'}}>Current Month: {monthLabel}</p>
                        
                        <div style={{display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '20px', marginBottom: '20px'}}>
                            <div style={{background: '#1a1f2e', padding: '20px', borderRadius: '10px', border: '2px solid #667eea'}}>
                                <h3 style={{color: '#667eea', marginBottom: '15px', fontSize: '1.2em'}}>üìä EXPECTED (Budget)</h3>
                                <div className="budget-row" style={{borderBottom: '1px solid #2d3748', paddingBottom: '10px'}}>
                                    <span className="budget-label">Expected Income:</span>
                                    <span className="budget-value" style={{fontSize: '1.1em'}}>{formatCurrency(expectedMonthlyIncome)}</span>
                                </div>
                                <div className="budget-row" style={{borderBottom: '1px solid #2d3748', paddingBottom: '10px'}}>
                                    <span className="budget-label">Recurring Bills:</span>
                                    <span className="budget-value negative" style={{fontSize: '1.1em'}}>-{formatCurrency(recurringTotal)}</span>
                                </div>
                                <div className="budget-row" style={{paddingTop: '10px'}}>
                                    <span className="budget-label" style={{color: '#e2e8f0', fontWeight: 'bold'}}>Money Left:</span>
                                    <span className="budget-value" style={{fontSize: '1.3em', fontWeight: 'bold'}}>{formatCurrency(moneyLeft)}</span>
                                </div>
                            </div>
                            
                            <div style={{background: '#1a1f2e', padding: '20px', borderRadius: '10px', border: '2px solid ' + (actualIncome >= expectedMonthlyIncome ? '#28a745' : '#ffc107')}}>
                                <h3 style={{color: actualIncome >= expectedMonthlyIncome ? '#28a745' : '#ffc107', marginBottom: '15px', fontSize: '1.2em'}}>üíµ ACTUAL (Current Reality)</h3>
                                <div className="budget-row" style={{borderBottom: '1px solid #2d3748', paddingBottom: '10px'}}>
                                    <span className="budget-label">Actual Income:</span>
                                    <span className={`budget-value ${actualIncome >= expectedMonthlyIncome ? 'positive' : 'warning'}`} style={{fontSize: '1.1em'}}>
                                        {formatCurrency(actualIncome)} {actualIncome < expectedMonthlyIncome && '‚ö†Ô∏è'}
                                    </span>
                                </div>
                                <div className="budget-row" style={{borderBottom: '1px solid #2d3748', paddingBottom: '10px'}}>
                                    <span className="budget-label">Recurring Bills:</span>
                                    <span className="budget-value negative" style={{fontSize: '1.1em'}}>-{formatCurrency(recurringTotal)}</span>
                                </div>
                                <div className="budget-row" style={{paddingTop: '10px'}}>
                                    <span className="budget-label" style={{color: '#e2e8f0', fontWeight: 'bold'}}>Money Left (actual):</span>
                                    <span className={`budget-value ${moneyLeftActual >= 0 ? 'positive' : 'negative'}`} style={{fontSize: '1.3em', fontWeight: 'bold'}}>
                                        {formatCurrency(moneyLeftActual)} {moneyLeftActual < 0 && '‚ö†Ô∏è'}
                                    </span>
                                </div>
                            </div>
                        </div>
                        
                        <div style={{borderTop: '2px solid #667eea', paddingTop: '20px'}}>
                            <div className="budget-row">
                                <span className="budget-label">Total Expenses (this month):</span>
                                <span className="budget-value">{formatCurrency(totalExpenses)}</span>
                            </div>
                            
                            <div className="budget-row">
                                <span className="budget-label">Unpaid Recurring (still due):</span>
                                <span className="budget-value warning">{formatCurrency(unpaidRecurring)}</span>
                            </div>
                            
                            <div className="budget-row">
                                <span className="budget-label">Spent So Far (non-recurring):</span>
                                <span className="budget-value negative">-{formatCurrency(spentSoFar)}</span>
                            </div>
                        </div>
                        
                        <div style={{borderTop: '3px solid #667eea', paddingTop: '20px', marginTop: '20px'}}>
                            <div className="budget-row total">
                                <span className="budget-label total">Remaining (if expected income comes):</span>
                                <span className={`budget-value ${remainingExpected >= 0 ? 'positive' : 'negative'}`} style={{fontSize: '1.4em'}}>
                                    {formatCurrency(remainingExpected)} {remainingExpected >= 0 ? '‚úì' : '‚ö†Ô∏è'}
                                </span>
                            </div>
                            
                            <div className="budget-row total">
                                <span className="budget-label total">Remaining (with current income):</span>
                                <span className={`budget-value ${remainingActual >= 0 ? 'positive' : 'negative'}`} style={{fontSize: '1.4em'}}>
                                    {formatCurrency(remainingActual)} {remainingActual >= 0 ? '‚úì' : '‚ö†Ô∏è'}
                                </span>
                            </div>
                        </div>
                    </div>

                    <div className="section">
                        <h2>üìä Budget Breakdown</h2>
                        <p style={{color: '#a0aec0', marginBottom: '20px', lineHeight: '1.6'}}>
                            Simple budget tracking: Income - Recurring Bills = Money Left, then subtract what you've spent on non-recurring items.
                        </p>
                        
                        <div style={{background: '#1a1f2e', padding: '20px', borderRadius: '10px'}}>
                            <div style={{marginBottom: '15px'}}>
                                <strong style={{color: '#667eea'}}>Expected Income:</strong>
                                <p style={{color: '#a0aec0', fontSize: '0.9em', marginTop: '5px'}}>
                                    The amount you expect to earn this month. Set this in the Income Settings above.
                                </p>
                            </div>
                            
                            <div style={{marginBottom: '15px'}}>
                                <strong style={{color: '#667eea'}}>Recurring Bills:</strong>
                                <p style={{color: '#a0aec0', fontSize: '0.9em', marginTop: '5px'}}>
                                    Total of all recurring payments due this month (from Recurring tab).
                                </p>
                            </div>
                            
                            <div style={{marginBottom: '15px'}}>
                                <strong style={{color: '#667eea'}}>Money Left:</strong>
                                <p style={{color: '#a0aec0', fontSize: '0.9em', marginTop: '5px'}}>
                                    Expected Income - Recurring Bills = Your budget for discretionary spending.
                                </p>
                            </div>
                            
                            <div style={{marginBottom: '15px'}}>
                                <strong style={{color: '#667eea'}}>Spent So Far:</strong>
                                <p style={{color: '#a0aec0', fontSize: '0.9em', marginTop: '5px'}}>
                                    Total Expenses - Recurring Bills = What you've actually spent on non-recurring items.
                                </p>
                            </div>
                            
                            <div>
                                <strong style={{color: '#667eea'}}>Remaining Available:</strong>
                                <p style={{color: '#a0aec0', fontSize: '0.9em', marginTop: '5px'}}>
                                    Money Left - Spent So Far - Unpaid Recurring = How much you truly have left to spend (accounting for bills still due).
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        function SettingsTab({ exportData, importData, clearAllData }) {
            return (
                <div>
                    <div className="section" style={{background: 'linear-gradient(135deg, #667eea22 0%, #764ba222 100%)', border: '2px solid #667eea', padding: '25px'}}>
                        <h2 style={{color: '#667eea', marginBottom: '15px'}}>‚ö° Important: No Auto-Save</h2>
                        <p style={{color: '#e2e8f0', fontSize: '1.05em', lineHeight: '1.8', marginBottom: '15px'}}>
                            <strong>This app does NOT use localStorage.</strong> Your data exists only in memory during your session.
                        </p>
                        <div style={{background: '#0f1419', padding: '20px', borderRadius: '10px'}}>
                            <h3 style={{color: '#667eea', marginBottom: '10px'}}>üìã Your Workflow:</h3>
                            <ol style={{color: '#a0aec0', lineHeight: '2', marginLeft: '20px'}}>
                                <li><strong style={{color: '#e2e8f0'}}>Start:</strong> Import your JSON file</li>
                                <li><strong style={{color: '#e2e8f0'}}>Work:</strong> Add transactions, process payments, etc.</li>
                                <li><strong style={{color: '#e2e8f0'}}>End:</strong> Export to save your changes</li>
                                <li><strong style={{color: '#e2e8f0'}}>Next time:</strong> Import the latest export to continue</li>
                            </ol>
                        </div>
                        <p style={{color: '#ffc107', fontSize: '0.95em', marginTop: '15px', fontWeight: '600'}}>
                            ‚ö†Ô∏è Closing/refreshing the page without exporting = data is lost!
                        </p>
                    </div>
                    <div className="section">
                        <h2>Data Management</h2>
                        <div className="controls">
                            <button onClick={exportData}>üíæ Export Data</button>
                            <label style={{background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)', color: 'white', padding: '12px 30px', borderRadius: '8px', cursor: 'pointer', fontWeight: 600, display: 'inline-block'}}>üìÅ Import Data<input type="file" accept=".json" onChange={importData} style={{display: 'none'}} /></label>
                            <button className="danger" onClick={clearAllData}>üóëÔ∏è Clear All Data</button>
                        </div>
                        <p style={{marginTop: '20px', color: '#a0aec0', fontSize: '0.9em'}}>Export your data to save a backup, import previously exported data, or clear all data to start fresh.</p>
                    </div>
                    <div className="section">
                        <h2>How to Use Finance Tracker</h2>
                        <p style={{marginBottom: '20px', lineHeight: '1.6', color: '#a0aec0'}}>Complete guide for new and existing users.</p>
                        
                        <div style={{background: 'linear-gradient(135deg, #28a74522 0%, #20c99722 100%)', border: '2px solid #28a745', padding: '20px', borderRadius: '10px', marginBottom: '30px'}}>
                            <h3 style={{color: '#28a745', marginBottom: '15px'}}>üéØ First-Time Setup (Recommended Order)</h3>
                            <ol style={{color: '#e2e8f0', lineHeight: '2', marginLeft: '20px'}}>
                                <li><strong>Set Expected Income:</strong> Go to <strong style={{color: '#667eea'}}>üíµ Budget</strong> tab ‚Üí Set your expected monthly income</li>
                                <li><strong>Add Debts:</strong> Go to <strong style={{color: '#667eea'}}>üìâ Debt Tracking</strong> tab ‚Üí Add all your debts (credit cards, loans, etc.)</li>
                                <li><strong>Add Recurring Payments:</strong> Go to <strong style={{color: '#667eea'}}>üîÑ Recurring</strong> tab ‚Üí Add monthly bills
                                    <ul style={{marginTop: '5px', marginLeft: '20px'}}>
                                        <li>Link debt payments to their corresponding debts for automatic balance tracking</li>
                                        <li>Enable "Auto-pay" checkbox for bills that should create transactions automatically</li>
                                    </ul>
                                </li>
                                <li><strong>Add Transactions:</strong> Go to <strong style={{color: '#667eea'}}>üí≥ Transactions</strong> tab ‚Üí Start adding your income and expenses</li>
                                <li><strong>Check Your Budget:</strong> Return to <strong style={{color: '#667eea'}}>üìä Dashboard</strong> to see your financial overview</li>
                            </ol>
                        </div>
                        
                        <h3 style={{marginTop: '20px', marginBottom: '10px', color: '#667eea'}}>üíµ Budget Tab - Money Available</h3>
                        <p style={{marginBottom: '10px', lineHeight: '1.6', color: '#a0aec0'}}>
                            <strong>What it shows:</strong> Expected vs Actual income comparison, and how much discretionary money you have left.<br/>
                            <strong>Key metrics:</strong> Shows "Remaining (if expected income comes)" and "Remaining (with current income)" so you can plan accordingly.<br/>
                            <strong>Updates:</strong> Set your expected monthly income here - it's used across the app for budget calculations.
                        </p>
                        
                        <h3 style={{marginTop: '20px', marginBottom: '10px', color: '#667eea'}}>üîÑ Auto-Pay Recurring Payments</h3>
                        <p style={{marginBottom: '10px', lineHeight: '1.6', color: '#a0aec0'}}>
                            <strong>What it does:</strong> Automatically creates transactions when the due date passes.<br/>
                            <strong>How to enable:</strong> When adding/editing a recurring payment, check the "Auto-pay" checkbox.<br/>
                            <strong>How it works:</strong> On the due date, a transaction is created automatically and the payment is marked as paid.<br/>
                            <strong>Best for:</strong> Bills that auto-pay from your account (Netflix, utilities, car payment, etc.)
                        </p>
                        
                        <h3 style={{marginTop: '20px', marginBottom: '10px', color: '#667eea'}}>üí≥ Linking Payments to Debts</h3>
                        <p style={{marginBottom: '10px', lineHeight: '1.6', color: '#a0aec0'}}>
                            <strong>What it does:</strong> Automatically updates debt balance and tracks interest/principal breakdown.<br/>
                            <strong>How to link:</strong> When adding/editing a recurring payment, select a debt from the "Link to Debt" dropdown.<br/>
                            <strong>What you get:</strong> Automatic balance updates + transaction history showing exactly how each payment reduces your debt.<br/>
                            <strong>Important:</strong> Add your debts FIRST before creating linked recurring payments.
                        </p>
                        
                        <h3 style={{marginTop: '20px', marginBottom: '10px', color: '#667eea'}}>üîç Search Transactions by Place</h3>
                        <p style={{marginBottom: '10px', lineHeight: '1.6', color: '#a0aec0'}}>
                            <strong>Where:</strong> Go to <strong style={{color: '#667eea'}}>üí≥ Transactions</strong> tab ‚Üí Use the search box at the top of Transaction History.<br/>
                            <strong>How it works:</strong> Type any place name (e.g., "7 Brew", "Kroger", "Amazon") to see all matching transactions.<br/>
                            <strong>Shows:</strong> Total spent at that place this month + all-time total.<br/>
                            <strong>Smart matching:</strong> Automatically handles variations like "7brew" vs "7 Brew" or "walmart" vs "Wal-Mart"
                        </p>
                        
                        <h3 style={{marginTop: '20px', marginBottom: '10px', color: '#667eea'}}>üìä Debt Transaction Logs</h3>
                        <p style={{marginBottom: '10px', lineHeight: '1.6', color: '#a0aec0'}}>
                            <strong>Where to find:</strong> Go to <strong style={{color: '#667eea'}}>üìâ Debt Tracking</strong> tab ‚Üí Click on a debt to expand ‚Üí Scroll to "Transaction History".<br/>
                            <strong>What it shows:</strong> Date, payment amount, interest charged, principal paid, and balance before/after.<br/>
                            <strong>Note:</strong> Only shows for debts with linked recurring payments that have been processed.
                        </p>
                        
                        <h3 style={{marginTop: '20px', marginBottom: '10px', color: '#667eea'}}>üìÖ Financial Month (28th-27th Cycle)</h3>
                        <p style={{marginBottom: '10px', lineHeight: '1.6', color: '#a0aec0'}}>
                            <strong>How it works:</strong> Financial months run from the 28th of one month through the 27th of the next.<br/>
                            <strong>Example:</strong> December 2025 = Nov 28 through Dec 27.<br/>
                            <strong>Why:</strong> Aligns with common payday cycles where bills are due early in the calendar month.<br/>
                            <strong>All calculations:</strong> Dashboard stats, Budget tab, and recurring payments all use this cycle.
                        </p>
                        
                        <h3 style={{marginTop: '20px', marginBottom: '10px', color: '#667eea'}}>üíæ Export & Import</h3>
                        <p style={{marginBottom: '10px', lineHeight: '1.6', color: '#a0aec0'}}>
                            <strong>Export:</strong> Creates a backup JSON file with all your data (transactions, debts, recurring payments, settings).<br/>
                            <strong>Import:</strong> Restores data from a backup file - can be done from Dashboard welcome screen or Settings tab.<br/>
                            <strong>Use case:</strong> Backup your data regularly, or move data between devices/browsers.<br/>
                            <strong>Workflow:</strong> Import ‚Üí Make changes ‚Üí Export to save. No auto-save!
                        </p>
                        
                        <p style={{marginTop: '30px', padding: '15px', background: '#1a1f2e', borderRadius: '8px', color: '#667eea', fontSize: '0.9em'}}>
                            <strong>üí° Pro Tip:</strong> Export your data at the end of each session! Without exporting, your changes will be lost when you close the page.
                        </p>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<FinanceTracker />, document.getElementById('root'));
    </script>
</body>
</html>
